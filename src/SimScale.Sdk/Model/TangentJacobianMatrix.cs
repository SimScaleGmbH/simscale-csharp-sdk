/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// &lt;p&gt;Select which stiffnes matrix should be used for computing the Jacobian of the Newton method. Choosing the tangent stiffnes matrix via &lt;b&gt;tangent matrix&lt;/b&gt; allows a full Newton approach whereas the selection of the &lt;b&gt;elastic matrix&lt;/b&gt; results in a quasi-Newton approach.&lt;/p&gt;
    /// </summary>
    [DataContract]
    public partial class TangentJacobianMatrix : OneOfNewtonKrylovResolutionTypeJacobianMatrix, OneOfNewtonResolutionTypeJacobianMatrix, IEquatable<TangentJacobianMatrix>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="TangentJacobianMatrix" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected TangentJacobianMatrix() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="TangentJacobianMatrix" /> class.
        /// </summary>
        /// <param name="type">type (required) (default to &quot;TANGENT&quot;).</param>
        /// <param name="maxNewtonIteration">&lt;p&gt;Maximum number of allowed Newton iterations per time increment. If this value is reached the simulation is considered non-converging. If an automatic time stepping is activated the time increment is reduced in order to reach convergence.&lt;/p&gt; (required).</param>
        /// <param name="reactualizationIteration">&lt;p&gt;Select how often the Jacobian matrix should be recomputed. If this parameter is set to 10, the Jacobian matrix is recomputed every 10th iteration within a given time step. If it is set to 0, the Jacobian matrix is not updated within any time step.&lt;/p&gt; (required).</param>
        /// <param name="reactualizationIncrement">&lt;p&gt;Select how often the Jacobian matrix should be recomputed. If this parameter is set to 10, the Jacobian matrix is recomputed every 10th time step. If it is set to 0, the Jacobian matrix is never updated.&lt;/p&gt; (default to 1).</param>
        /// <param name="changeJacobianMatrix">changeJacobianMatrix.</param>
        public TangentJacobianMatrix(string type = "TANGENT", int? maxNewtonIteration = default(int?), int? reactualizationIteration = default(int?), int? reactualizationIncrement = default(int?), OneOfTangentJacobianMatrixChangeJacobianMatrix changeJacobianMatrix = default(OneOfTangentJacobianMatrixChangeJacobianMatrix))
        {
            // to ensure "type" is required (not null)
            this.Type = type ?? throw new ArgumentNullException("type is a required property for TangentJacobianMatrix and cannot be null");
            // to ensure "maxNewtonIteration" is required (not null)
            this.MaxNewtonIteration = maxNewtonIteration ?? throw new ArgumentNullException("maxNewtonIteration is a required property for TangentJacobianMatrix and cannot be null");
            // to ensure "reactualizationIteration" is required (not null)
            this.ReactualizationIteration = reactualizationIteration ?? throw new ArgumentNullException("reactualizationIteration is a required property for TangentJacobianMatrix and cannot be null");
            this.ReactualizationIncrement = reactualizationIncrement;
            this.ChangeJacobianMatrix = changeJacobianMatrix;
        }
        
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public string Type { get; set; }

        /// <summary>
        /// &lt;p&gt;Maximum number of allowed Newton iterations per time increment. If this value is reached the simulation is considered non-converging. If an automatic time stepping is activated the time increment is reduced in order to reach convergence.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Maximum number of allowed Newton iterations per time increment. If this value is reached the simulation is considered non-converging. If an automatic time stepping is activated the time increment is reduced in order to reach convergence.&lt;/p&gt;</value>
        [DataMember(Name="maxNewtonIteration", EmitDefaultValue=false)]
        public int? MaxNewtonIteration { get; set; }

        /// <summary>
        /// &lt;p&gt;Select how often the Jacobian matrix should be recomputed. If this parameter is set to 10, the Jacobian matrix is recomputed every 10th iteration within a given time step. If it is set to 0, the Jacobian matrix is not updated within any time step.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Select how often the Jacobian matrix should be recomputed. If this parameter is set to 10, the Jacobian matrix is recomputed every 10th iteration within a given time step. If it is set to 0, the Jacobian matrix is not updated within any time step.&lt;/p&gt;</value>
        [DataMember(Name="reactualizationIteration", EmitDefaultValue=false)]
        public int? ReactualizationIteration { get; set; }

        /// <summary>
        /// &lt;p&gt;Select how often the Jacobian matrix should be recomputed. If this parameter is set to 10, the Jacobian matrix is recomputed every 10th time step. If it is set to 0, the Jacobian matrix is never updated.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Select how often the Jacobian matrix should be recomputed. If this parameter is set to 10, the Jacobian matrix is recomputed every 10th time step. If it is set to 0, the Jacobian matrix is never updated.&lt;/p&gt;</value>
        [DataMember(Name="reactualizationIncrement", EmitDefaultValue=false)]
        public int? ReactualizationIncrement { get; set; }

        /// <summary>
        /// Gets or Sets ChangeJacobianMatrix
        /// </summary>
        [DataMember(Name="changeJacobianMatrix", EmitDefaultValue=false)]
        public OneOfTangentJacobianMatrixChangeJacobianMatrix ChangeJacobianMatrix { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class TangentJacobianMatrix {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  MaxNewtonIteration: ").Append(MaxNewtonIteration).Append("\n");
            sb.Append("  ReactualizationIteration: ").Append(ReactualizationIteration).Append("\n");
            sb.Append("  ReactualizationIncrement: ").Append(ReactualizationIncrement).Append("\n");
            sb.Append("  ChangeJacobianMatrix: ").Append(ChangeJacobianMatrix).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as TangentJacobianMatrix);
        }

        /// <summary>
        /// Returns true if TangentJacobianMatrix instances are equal
        /// </summary>
        /// <param name="input">Instance of TangentJacobianMatrix to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(TangentJacobianMatrix input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.MaxNewtonIteration == input.MaxNewtonIteration ||
                    (this.MaxNewtonIteration != null &&
                    this.MaxNewtonIteration.Equals(input.MaxNewtonIteration))
                ) && 
                (
                    this.ReactualizationIteration == input.ReactualizationIteration ||
                    (this.ReactualizationIteration != null &&
                    this.ReactualizationIteration.Equals(input.ReactualizationIteration))
                ) && 
                (
                    this.ReactualizationIncrement == input.ReactualizationIncrement ||
                    (this.ReactualizationIncrement != null &&
                    this.ReactualizationIncrement.Equals(input.ReactualizationIncrement))
                ) && 
                (
                    this.ChangeJacobianMatrix == input.ChangeJacobianMatrix ||
                    (this.ChangeJacobianMatrix != null &&
                    this.ChangeJacobianMatrix.Equals(input.ChangeJacobianMatrix))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.MaxNewtonIteration != null)
                    hashCode = hashCode * 59 + this.MaxNewtonIteration.GetHashCode();
                if (this.ReactualizationIteration != null)
                    hashCode = hashCode * 59 + this.ReactualizationIteration.GetHashCode();
                if (this.ReactualizationIncrement != null)
                    hashCode = hashCode * 59 + this.ReactualizationIncrement.GetHashCode();
                if (this.ChangeJacobianMatrix != null)
                    hashCode = hashCode * 59 + this.ChangeJacobianMatrix.GetHashCode();
                return hashCode;
            }
        }

    }

}
