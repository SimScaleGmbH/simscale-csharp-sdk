/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// HexDominantSnappy
    /// </summary>
    [DataContract]
    public partial class HexDominantSnappy : Algorithm, IEquatable<HexDominantSnappy>
    {
        /// <summary>
        /// &lt;p&gt;The &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#meshing-mode&#39; target&#x3D;&#39;_blank&#39;&gt;meshing mode&lt;/a&gt; defines how the mesher should generate the mesh.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The &lt;b&gt;Internal&lt;/b&gt; mode will create the mesh &lt;u&gt;inside&lt;/u&gt; of the geometry body. If the CAD consists of multiple solids, the mesher will attempt to create a multiregion mesh which is suitable for conjugate heat transfer analyses. Use this mode if the CAD model already represents the final fluid domain.&lt;/li&gt;&lt;li&gt;&lt;b&gt;External&lt;/b&gt; meshing will create the mesh &lt;u&gt;outside&lt;/u&gt; of the bodies. The absolute dimensions of the mesh are determined by the &lt;i&gt;Background Mesh Box&lt;/i&gt;. Use this mode in case you want to extract the fluid domain around your model.&lt;/li&gt;&lt;li&gt;The option &lt;b&gt;Material point&lt;/b&gt; allows you to define a point inside the domain where the mesh will be placed. It can be used to select which part (or enclosed volume) of the model or should be meshed. The mesh will surround the material point and extend until the boundaries of the body. The location of the material point is defined by the &lt;i&gt;Material Point&lt;/i&gt; geometry primitive.&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>&lt;p&gt;The &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#meshing-mode&#39; target&#x3D;&#39;_blank&#39;&gt;meshing mode&lt;/a&gt; defines how the mesher should generate the mesh.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The &lt;b&gt;Internal&lt;/b&gt; mode will create the mesh &lt;u&gt;inside&lt;/u&gt; of the geometry body. If the CAD consists of multiple solids, the mesher will attempt to create a multiregion mesh which is suitable for conjugate heat transfer analyses. Use this mode if the CAD model already represents the final fluid domain.&lt;/li&gt;&lt;li&gt;&lt;b&gt;External&lt;/b&gt; meshing will create the mesh &lt;u&gt;outside&lt;/u&gt; of the bodies. The absolute dimensions of the mesh are determined by the &lt;i&gt;Background Mesh Box&lt;/i&gt;. Use this mode in case you want to extract the fluid domain around your model.&lt;/li&gt;&lt;li&gt;The option &lt;b&gt;Material point&lt;/b&gt; allows you to define a point inside the domain where the mesh will be placed. It can be used to select which part (or enclosed volume) of the model or should be meshed. The mesh will surround the material point and extend until the boundaries of the body. The location of the material point is defined by the &lt;i&gt;Material Point&lt;/i&gt; geometry primitive.&lt;/li&gt;&lt;/ul&gt;</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum MeshingModeEnum
        {
            /// <summary>
            /// Enum INTERNAL for value: INTERNAL
            /// </summary>
            [EnumMember(Value = "INTERNAL")]
            INTERNAL = 1

        }

        /// <summary>
        /// &lt;p&gt;The &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#meshing-mode&#39; target&#x3D;&#39;_blank&#39;&gt;meshing mode&lt;/a&gt; defines how the mesher should generate the mesh.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The &lt;b&gt;Internal&lt;/b&gt; mode will create the mesh &lt;u&gt;inside&lt;/u&gt; of the geometry body. If the CAD consists of multiple solids, the mesher will attempt to create a multiregion mesh which is suitable for conjugate heat transfer analyses. Use this mode if the CAD model already represents the final fluid domain.&lt;/li&gt;&lt;li&gt;&lt;b&gt;External&lt;/b&gt; meshing will create the mesh &lt;u&gt;outside&lt;/u&gt; of the bodies. The absolute dimensions of the mesh are determined by the &lt;i&gt;Background Mesh Box&lt;/i&gt;. Use this mode in case you want to extract the fluid domain around your model.&lt;/li&gt;&lt;li&gt;The option &lt;b&gt;Material point&lt;/b&gt; allows you to define a point inside the domain where the mesh will be placed. It can be used to select which part (or enclosed volume) of the model or should be meshed. The mesh will surround the material point and extend until the boundaries of the body. The location of the material point is defined by the &lt;i&gt;Material Point&lt;/i&gt; geometry primitive.&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>&lt;p&gt;The &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#meshing-mode&#39; target&#x3D;&#39;_blank&#39;&gt;meshing mode&lt;/a&gt; defines how the mesher should generate the mesh.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The &lt;b&gt;Internal&lt;/b&gt; mode will create the mesh &lt;u&gt;inside&lt;/u&gt; of the geometry body. If the CAD consists of multiple solids, the mesher will attempt to create a multiregion mesh which is suitable for conjugate heat transfer analyses. Use this mode if the CAD model already represents the final fluid domain.&lt;/li&gt;&lt;li&gt;&lt;b&gt;External&lt;/b&gt; meshing will create the mesh &lt;u&gt;outside&lt;/u&gt; of the bodies. The absolute dimensions of the mesh are determined by the &lt;i&gt;Background Mesh Box&lt;/i&gt;. Use this mode in case you want to extract the fluid domain around your model.&lt;/li&gt;&lt;li&gt;The option &lt;b&gt;Material point&lt;/b&gt; allows you to define a point inside the domain where the mesh will be placed. It can be used to select which part (or enclosed volume) of the model or should be meshed. The mesh will surround the material point and extend until the boundaries of the body. The location of the material point is defined by the &lt;i&gt;Material Point&lt;/i&gt; geometry primitive.&lt;/li&gt;&lt;/ul&gt;</value>
        [DataMember(Name="meshingMode", EmitDefaultValue=false)]
        public MeshingModeEnum? MeshingMode { get; set; }
        /// <summary>
        /// &lt;p&gt;Selecting more processor cores might speed up the meshing process. Choosing a smaller computation instance will save core hours. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/#number-of-processors&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Selecting more processor cores might speed up the meshing process. Choosing a smaller computation instance will save core hours. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/#number-of-processors&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;</value>
        public enum NumOfProcessorsEnum
        {
            /// <summary>
            /// Enum NUMBER_MINUS_1 for value: -1
            /// </summary>
            NUMBER_MINUS_1 = -1,

            /// <summary>
            /// Enum NUMBER_4 for value: 4
            /// </summary>
            NUMBER_4 = 4,

            /// <summary>
            /// Enum NUMBER_8 for value: 8
            /// </summary>
            NUMBER_8 = 8,

            /// <summary>
            /// Enum NUMBER_16 for value: 16
            /// </summary>
            NUMBER_16 = 16,

            /// <summary>
            /// Enum NUMBER_32 for value: 32
            /// </summary>
            NUMBER_32 = 32,

            /// <summary>
            /// Enum NUMBER_64 for value: 64
            /// </summary>
            NUMBER_64 = 64,

            /// <summary>
            /// Enum NUMBER_96 for value: 96
            /// </summary>
            NUMBER_96 = 96

        }

        /// <summary>
        /// &lt;p&gt;Selecting more processor cores might speed up the meshing process. Choosing a smaller computation instance will save core hours. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/#number-of-processors&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Selecting more processor cores might speed up the meshing process. Choosing a smaller computation instance will save core hours. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/#number-of-processors&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;</value>
        [DataMember(Name="numOfProcessors", EmitDefaultValue=false)]
        public NumOfProcessorsEnum? NumOfProcessors { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="HexDominantSnappy" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected HexDominantSnappy() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="HexDominantSnappy" /> class.
        /// </summary>
        /// <param name="type">Schema name: HexDominantSnappy (required) (default to &quot;HEX_DOMINANT_SNAPPY_V5&quot;).</param>
        /// <param name="meshingMode">&lt;p&gt;The &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#meshing-mode&#39; target&#x3D;&#39;_blank&#39;&gt;meshing mode&lt;/a&gt; defines how the mesher should generate the mesh.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;The &lt;b&gt;Internal&lt;/b&gt; mode will create the mesh &lt;u&gt;inside&lt;/u&gt; of the geometry body. If the CAD consists of multiple solids, the mesher will attempt to create a multiregion mesh which is suitable for conjugate heat transfer analyses. Use this mode if the CAD model already represents the final fluid domain.&lt;/li&gt;&lt;li&gt;&lt;b&gt;External&lt;/b&gt; meshing will create the mesh &lt;u&gt;outside&lt;/u&gt; of the bodies. The absolute dimensions of the mesh are determined by the &lt;i&gt;Background Mesh Box&lt;/i&gt;. Use this mode in case you want to extract the fluid domain around your model.&lt;/li&gt;&lt;li&gt;The option &lt;b&gt;Material point&lt;/b&gt; allows you to define a point inside the domain where the mesh will be placed. It can be used to select which part (or enclosed volume) of the model or should be meshed. The mesh will surround the material point and extend until the boundaries of the body. The location of the material point is defined by the &lt;i&gt;Material Point&lt;/i&gt; geometry primitive.&lt;/li&gt;&lt;/ul&gt; (default to MeshingModeEnum.INTERNAL).</param>
        /// <param name="sizing">sizing.</param>
        /// <param name="physicsBasedMeshing">Physics-based meshing takes setup information like materials, boundary conditions, and source terms into account to size the mesh accordingly. When enabled, the following adaptations will be made:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Refinements on inlets and outlets&lt;/li&gt;&lt;li&gt;Different sizing for solid and fluid regions in CHT simulations&lt;/li&gt;&lt;/ul&gt; &lt;br&gt;When toggled on users don’t have to worry about creating a &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/simulation-control/&#39; target&#x3D;&#39;_blank&#39;&gt;separate cell zone&lt;/a&gt;. (default to true).</param>
        /// <param name="numOfProcessors">&lt;p&gt;Selecting more processor cores might speed up the meshing process. Choosing a smaller computation instance will save core hours. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/#number-of-processors&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt; (default to NumOfProcessorsEnum.NUMBER_MINUS_1).</param>
        /// <param name="refinements">refinements.</param>
        public HexDominantSnappy(string type = "HEX_DOMINANT_SNAPPY_V5", MeshingModeEnum? meshingMode = default(MeshingModeEnum?), OneOfHexDominantSnappySizing sizing = default(OneOfHexDominantSnappySizing), bool? physicsBasedMeshing = default(bool?), NumOfProcessorsEnum? numOfProcessors = default(NumOfProcessorsEnum?), List<OneOfHexDominantSnappyRefinements> refinements = default(List<OneOfHexDominantSnappyRefinements>))
        {
            // to ensure "type" is required (not null)
            this.Type = type ?? throw new ArgumentNullException("type is a required property for HexDominantSnappy and cannot be null");
            this.MeshingMode = meshingMode;
            this.Sizing = sizing;
            this.PhysicsBasedMeshing = physicsBasedMeshing;
            this.NumOfProcessors = numOfProcessors;
            this.Refinements = refinements;
        }
        
        /// <summary>
        /// Schema name: HexDominantSnappy
        /// </summary>
        /// <value>Schema name: HexDominantSnappy</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public string Type { get; set; }

        /// <summary>
        /// Gets or Sets Sizing
        /// </summary>
        [DataMember(Name="sizing", EmitDefaultValue=false)]
        public OneOfHexDominantSnappySizing Sizing { get; set; }

        /// <summary>
        /// Physics-based meshing takes setup information like materials, boundary conditions, and source terms into account to size the mesh accordingly. When enabled, the following adaptations will be made:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Refinements on inlets and outlets&lt;/li&gt;&lt;li&gt;Different sizing for solid and fluid regions in CHT simulations&lt;/li&gt;&lt;/ul&gt; &lt;br&gt;When toggled on users don’t have to worry about creating a &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/simulation-control/&#39; target&#x3D;&#39;_blank&#39;&gt;separate cell zone&lt;/a&gt;.
        /// </summary>
        /// <value>Physics-based meshing takes setup information like materials, boundary conditions, and source terms into account to size the mesh accordingly. When enabled, the following adaptations will be made:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Refinements on inlets and outlets&lt;/li&gt;&lt;li&gt;Different sizing for solid and fluid regions in CHT simulations&lt;/li&gt;&lt;/ul&gt; &lt;br&gt;When toggled on users don’t have to worry about creating a &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/simulation-control/&#39; target&#x3D;&#39;_blank&#39;&gt;separate cell zone&lt;/a&gt;.</value>
        [DataMember(Name="physicsBasedMeshing", EmitDefaultValue=false)]
        public bool? PhysicsBasedMeshing { get; set; }

        /// <summary>
        /// Gets or Sets Refinements
        /// </summary>
        [DataMember(Name="refinements", EmitDefaultValue=false)]
        public List<OneOfHexDominantSnappyRefinements> Refinements { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class HexDominantSnappy {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  MeshingMode: ").Append(MeshingMode).Append("\n");
            sb.Append("  Sizing: ").Append(Sizing).Append("\n");
            sb.Append("  PhysicsBasedMeshing: ").Append(PhysicsBasedMeshing).Append("\n");
            sb.Append("  NumOfProcessors: ").Append(NumOfProcessors).Append("\n");
            sb.Append("  Refinements: ").Append(Refinements).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as HexDominantSnappy);
        }

        /// <summary>
        /// Returns true if HexDominantSnappy instances are equal
        /// </summary>
        /// <param name="input">Instance of HexDominantSnappy to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(HexDominantSnappy input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.MeshingMode == input.MeshingMode ||
                    this.MeshingMode.Equals(input.MeshingMode)
                ) && 
                (
                    this.Sizing == input.Sizing ||
                    (this.Sizing != null &&
                    this.Sizing.Equals(input.Sizing))
                ) && 
                (
                    this.PhysicsBasedMeshing == input.PhysicsBasedMeshing ||
                    (this.PhysicsBasedMeshing != null &&
                    this.PhysicsBasedMeshing.Equals(input.PhysicsBasedMeshing))
                ) && 
                (
                    this.NumOfProcessors == input.NumOfProcessors ||
                    this.NumOfProcessors.Equals(input.NumOfProcessors)
                ) && 
                (
                    this.Refinements == input.Refinements ||
                    this.Refinements != null &&
                    input.Refinements != null &&
                    this.Refinements.SequenceEqual(input.Refinements)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                hashCode = hashCode * 59 + this.MeshingMode.GetHashCode();
                if (this.Sizing != null)
                    hashCode = hashCode * 59 + this.Sizing.GetHashCode();
                if (this.PhysicsBasedMeshing != null)
                    hashCode = hashCode * 59 + this.PhysicsBasedMeshing.GetHashCode();
                hashCode = hashCode * 59 + this.NumOfProcessors.GetHashCode();
                if (this.Refinements != null)
                    hashCode = hashCode * 59 + this.Refinements.GetHashCode();
                return hashCode;
            }
        }

    }

}
