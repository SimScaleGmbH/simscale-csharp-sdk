/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/meshing/hex-dominant/#layers-refinement&#39; target&#x3D;&#39;_blank&#39;&gt;&lt;b&gt;Inflated boundary layers&lt;/b&gt;&lt;/a&gt; are used to resolve the boundary layer near walls (no-slip) which are in contact with the fluid. Using boundary layers is generally recommended for turbulent simulations.
    /// </summary>
    [DataContract]
    public partial class LayerAddition : IEquatable<LayerAddition>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="LayerAddition" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected LayerAddition() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="LayerAddition" /> class.
        /// </summary>
        /// <param name="type">type (required) (default to &quot;LAYER_ADDITION&quot;).</param>
        /// <param name="name">name (default to &quot;Inflate boundary layer&quot;).</param>
        /// <param name="layers">The number of &lt;b&gt;layers&lt;/b&gt; defines how many boundary layers should be created. (default to 5).</param>
        /// <param name="expansionRatio">&lt;p&gt;The &lt;b&gt;Expansion ratio&lt;/b&gt; determines how the boundary layers grow in thickness from the wall to the internal mesh. The larger the ratio, the larger each cell layer will be in comparison to the neighbouring layer closer to the wall.&lt;/p&gt;&lt;p&gt;&lt;img src&#x3D;\&quot;/spec/resources/help/imgs/shm_bl_expansion-ratio.png\&quot; class&#x3D;\&quot;helpPopupImage\&quot;/&gt; The figure shows a ratio of 1.3.&lt;/p&gt; (default to 1.3M).</param>
        /// <param name="minThickness">&lt;p&gt;This is the overall minimum thickness of all added layers. If for any case the overall layer thickness is smaller than this value, the layer addition process is stopped and no layers are added. In case the &#39;Use relative size for layers?&#39; option in the global settings is set to &#39;true&#39;, this thickness is relative to the undistorted size of the cells in the internal mesh directly next to the boundary layer.&lt;/p&gt; (default to 0.01M).</param>
        /// <param name="finalLayerThickness">&lt;p&gt;Specify the desired final layer thickness farthest away from the wall on which the boundary layer is grown. If the &#39;Layer Size&#39; toggle in the hex-parametric global settings is turned on, this thickness is relative to the undistorted size of the cells in the internal mesh directly next to the boundary layer.&lt;/p&gt; (default to 0.3M).</param>
        /// <param name="topologicalReference">topologicalReference.</param>
        public LayerAddition(string type = "LAYER_ADDITION", string name = default(string), int? layers = default(int?), decimal? expansionRatio = default(decimal?), decimal? minThickness = default(decimal?), decimal? finalLayerThickness = default(decimal?), TopologicalReference topologicalReference = default(TopologicalReference))
        {
            // to ensure "type" is required (not null)
            this.Type = type ?? throw new ArgumentNullException("type is a required property for LayerAddition and cannot be null");
            this.Name = name;
            this.Layers = layers;
            this.ExpansionRatio = expansionRatio;
            this.MinThickness = minThickness;
            this.FinalLayerThickness = finalLayerThickness;
            this.TopologicalReference = topologicalReference;
        }
        
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public string Type { get; set; }

        /// <summary>
        /// Gets or Sets Name
        /// </summary>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// The number of &lt;b&gt;layers&lt;/b&gt; defines how many boundary layers should be created.
        /// </summary>
        /// <value>The number of &lt;b&gt;layers&lt;/b&gt; defines how many boundary layers should be created.</value>
        [DataMember(Name="layers", EmitDefaultValue=false)]
        public int? Layers { get; set; }

        /// <summary>
        /// &lt;p&gt;The &lt;b&gt;Expansion ratio&lt;/b&gt; determines how the boundary layers grow in thickness from the wall to the internal mesh. The larger the ratio, the larger each cell layer will be in comparison to the neighbouring layer closer to the wall.&lt;/p&gt;&lt;p&gt;&lt;img src&#x3D;\&quot;/spec/resources/help/imgs/shm_bl_expansion-ratio.png\&quot; class&#x3D;\&quot;helpPopupImage\&quot;/&gt; The figure shows a ratio of 1.3.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;The &lt;b&gt;Expansion ratio&lt;/b&gt; determines how the boundary layers grow in thickness from the wall to the internal mesh. The larger the ratio, the larger each cell layer will be in comparison to the neighbouring layer closer to the wall.&lt;/p&gt;&lt;p&gt;&lt;img src&#x3D;\&quot;/spec/resources/help/imgs/shm_bl_expansion-ratio.png\&quot; class&#x3D;\&quot;helpPopupImage\&quot;/&gt; The figure shows a ratio of 1.3.&lt;/p&gt;</value>
        [DataMember(Name="expansionRatio", EmitDefaultValue=false)]
        public decimal? ExpansionRatio { get; set; }

        /// <summary>
        /// &lt;p&gt;This is the overall minimum thickness of all added layers. If for any case the overall layer thickness is smaller than this value, the layer addition process is stopped and no layers are added. In case the &#39;Use relative size for layers?&#39; option in the global settings is set to &#39;true&#39;, this thickness is relative to the undistorted size of the cells in the internal mesh directly next to the boundary layer.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;This is the overall minimum thickness of all added layers. If for any case the overall layer thickness is smaller than this value, the layer addition process is stopped and no layers are added. In case the &#39;Use relative size for layers?&#39; option in the global settings is set to &#39;true&#39;, this thickness is relative to the undistorted size of the cells in the internal mesh directly next to the boundary layer.&lt;/p&gt;</value>
        [DataMember(Name="minThickness", EmitDefaultValue=false)]
        public decimal? MinThickness { get; set; }

        /// <summary>
        /// &lt;p&gt;Specify the desired final layer thickness farthest away from the wall on which the boundary layer is grown. If the &#39;Layer Size&#39; toggle in the hex-parametric global settings is turned on, this thickness is relative to the undistorted size of the cells in the internal mesh directly next to the boundary layer.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Specify the desired final layer thickness farthest away from the wall on which the boundary layer is grown. If the &#39;Layer Size&#39; toggle in the hex-parametric global settings is turned on, this thickness is relative to the undistorted size of the cells in the internal mesh directly next to the boundary layer.&lt;/p&gt;</value>
        [DataMember(Name="finalLayerThickness", EmitDefaultValue=false)]
        public decimal? FinalLayerThickness { get; set; }

        /// <summary>
        /// Gets or Sets TopologicalReference
        /// </summary>
        [DataMember(Name="topologicalReference", EmitDefaultValue=false)]
        public TopologicalReference TopologicalReference { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class LayerAddition {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Layers: ").Append(Layers).Append("\n");
            sb.Append("  ExpansionRatio: ").Append(ExpansionRatio).Append("\n");
            sb.Append("  MinThickness: ").Append(MinThickness).Append("\n");
            sb.Append("  FinalLayerThickness: ").Append(FinalLayerThickness).Append("\n");
            sb.Append("  TopologicalReference: ").Append(TopologicalReference).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as LayerAddition);
        }

        /// <summary>
        /// Returns true if LayerAddition instances are equal
        /// </summary>
        /// <param name="input">Instance of LayerAddition to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(LayerAddition input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Layers == input.Layers ||
                    (this.Layers != null &&
                    this.Layers.Equals(input.Layers))
                ) && 
                (
                    this.ExpansionRatio == input.ExpansionRatio ||
                    (this.ExpansionRatio != null &&
                    this.ExpansionRatio.Equals(input.ExpansionRatio))
                ) && 
                (
                    this.MinThickness == input.MinThickness ||
                    (this.MinThickness != null &&
                    this.MinThickness.Equals(input.MinThickness))
                ) && 
                (
                    this.FinalLayerThickness == input.FinalLayerThickness ||
                    (this.FinalLayerThickness != null &&
                    this.FinalLayerThickness.Equals(input.FinalLayerThickness))
                ) && 
                (
                    this.TopologicalReference == input.TopologicalReference ||
                    (this.TopologicalReference != null &&
                    this.TopologicalReference.Equals(input.TopologicalReference))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.Layers != null)
                    hashCode = hashCode * 59 + this.Layers.GetHashCode();
                if (this.ExpansionRatio != null)
                    hashCode = hashCode * 59 + this.ExpansionRatio.GetHashCode();
                if (this.MinThickness != null)
                    hashCode = hashCode * 59 + this.MinThickness.GetHashCode();
                if (this.FinalLayerThickness != null)
                    hashCode = hashCode * 59 + this.FinalLayerThickness.GetHashCode();
                if (this.TopologicalReference != null)
                    hashCode = hashCode * 59 + this.TopologicalReference.GetHashCode();
                return hashCode;
            }
        }

    }

}
