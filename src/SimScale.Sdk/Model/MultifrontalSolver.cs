/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// MultifrontalSolver
    /// </summary>
    [DataContract]
    public partial class MultifrontalSolver : OneOfModalSolverSolver, OneOfSolidNumericsSolver, IEquatable<MultifrontalSolver>
    {
        /// <summary>
        /// Choose a renumbering method for the solution process.&lt;br/&gt;For large models around and above 50000 degrees of freedom you should consider using MDA.
        /// </summary>
        /// <value>Choose a renumbering method for the solution process.&lt;br/&gt;For large models around and above 50000 degrees of freedom you should consider using MDA.</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum RenumberingMethodEnum
        {
            /// <summary>
            /// Enum MDA for value: MDA
            /// </summary>
            [EnumMember(Value = "MDA")]
            MDA = 1,

            /// <summary>
            /// Enum MD for value: MD
            /// </summary>
            [EnumMember(Value = "MD")]
            MD = 2

        }

        /// <summary>
        /// Choose a renumbering method for the solution process.&lt;br/&gt;For large models around and above 50000 degrees of freedom you should consider using MDA.
        /// </summary>
        /// <value>Choose a renumbering method for the solution process.&lt;br/&gt;For large models around and above 50000 degrees of freedom you should consider using MDA.</value>
        [DataMember(Name="renumberingMethod", EmitDefaultValue=false)]
        public RenumberingMethodEnum? RenumberingMethod { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="MultifrontalSolver" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected MultifrontalSolver() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MultifrontalSolver" /> class.
        /// </summary>
        /// <param name="type">Schema name: MultifrontalSolver (required) (default to &quot;MULTIFRONT&quot;).</param>
        /// <param name="renumberingMethod">Choose a renumbering method for the solution process.&lt;br/&gt;For large models around and above 50000 degrees of freedom you should consider using MDA. (default to RenumberingMethodEnum.MDA).</param>
        /// <param name="forceSymmetric">Choose if you want to enforce a symmetric matrix. (default to false).</param>
        /// <param name="precisionSingularityDetection">Define the precision value for the detection of a singular matrix. Positive values enable the check, with 9 being a good starting point. Smaller values make the check more strict. This is an advanced option that should only be used to debug a model. (default to 8).</param>
        /// <param name="stopIfSingular">Choose if the calculation should be stopped if the problem turns out to be singular. (default to true).</param>
        /// <param name="eliminateLagrangeMultipliers">This option makes it possible to eliminate the Lagrange Multipliers which are introduced by generalized boundary conditions like bonded contact, remote boundary conditions and symmetry conditions. If activated, this option removes the Lagrange Multipliers which leads to a reduction of the total number of unknowns and can increase the robustness of iterative solvers. (default to false).</param>
        public MultifrontalSolver(string type = "MULTIFRONT", RenumberingMethodEnum? renumberingMethod = default(RenumberingMethodEnum?), bool? forceSymmetric = default(bool?), int? precisionSingularityDetection = default(int?), bool? stopIfSingular = default(bool?), bool? eliminateLagrangeMultipliers = default(bool?))
        {
            // to ensure "type" is required (not null)
            this.Type = type ?? throw new ArgumentNullException("type is a required property for MultifrontalSolver and cannot be null");
            this.RenumberingMethod = renumberingMethod;
            this.ForceSymmetric = forceSymmetric;
            this.PrecisionSingularityDetection = precisionSingularityDetection;
            this.StopIfSingular = stopIfSingular;
            this.EliminateLagrangeMultipliers = eliminateLagrangeMultipliers;
        }
        
        /// <summary>
        /// Schema name: MultifrontalSolver
        /// </summary>
        /// <value>Schema name: MultifrontalSolver</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public string Type { get; set; }

        /// <summary>
        /// Choose if you want to enforce a symmetric matrix.
        /// </summary>
        /// <value>Choose if you want to enforce a symmetric matrix.</value>
        [DataMember(Name="forceSymmetric", EmitDefaultValue=false)]
        public bool? ForceSymmetric { get; set; }

        /// <summary>
        /// Define the precision value for the detection of a singular matrix. Positive values enable the check, with 9 being a good starting point. Smaller values make the check more strict. This is an advanced option that should only be used to debug a model.
        /// </summary>
        /// <value>Define the precision value for the detection of a singular matrix. Positive values enable the check, with 9 being a good starting point. Smaller values make the check more strict. This is an advanced option that should only be used to debug a model.</value>
        [DataMember(Name="precisionSingularityDetection", EmitDefaultValue=false)]
        public int? PrecisionSingularityDetection { get; set; }

        /// <summary>
        /// Choose if the calculation should be stopped if the problem turns out to be singular.
        /// </summary>
        /// <value>Choose if the calculation should be stopped if the problem turns out to be singular.</value>
        [DataMember(Name="stopIfSingular", EmitDefaultValue=false)]
        public bool? StopIfSingular { get; set; }

        /// <summary>
        /// This option makes it possible to eliminate the Lagrange Multipliers which are introduced by generalized boundary conditions like bonded contact, remote boundary conditions and symmetry conditions. If activated, this option removes the Lagrange Multipliers which leads to a reduction of the total number of unknowns and can increase the robustness of iterative solvers.
        /// </summary>
        /// <value>This option makes it possible to eliminate the Lagrange Multipliers which are introduced by generalized boundary conditions like bonded contact, remote boundary conditions and symmetry conditions. If activated, this option removes the Lagrange Multipliers which leads to a reduction of the total number of unknowns and can increase the robustness of iterative solvers.</value>
        [DataMember(Name="eliminateLagrangeMultipliers", EmitDefaultValue=false)]
        public bool? EliminateLagrangeMultipliers { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class MultifrontalSolver {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  RenumberingMethod: ").Append(RenumberingMethod).Append("\n");
            sb.Append("  ForceSymmetric: ").Append(ForceSymmetric).Append("\n");
            sb.Append("  PrecisionSingularityDetection: ").Append(PrecisionSingularityDetection).Append("\n");
            sb.Append("  StopIfSingular: ").Append(StopIfSingular).Append("\n");
            sb.Append("  EliminateLagrangeMultipliers: ").Append(EliminateLagrangeMultipliers).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MultifrontalSolver);
        }

        /// <summary>
        /// Returns true if MultifrontalSolver instances are equal
        /// </summary>
        /// <param name="input">Instance of MultifrontalSolver to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MultifrontalSolver input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.RenumberingMethod == input.RenumberingMethod ||
                    this.RenumberingMethod.Equals(input.RenumberingMethod)
                ) && 
                (
                    this.ForceSymmetric == input.ForceSymmetric ||
                    (this.ForceSymmetric != null &&
                    this.ForceSymmetric.Equals(input.ForceSymmetric))
                ) && 
                (
                    this.PrecisionSingularityDetection == input.PrecisionSingularityDetection ||
                    (this.PrecisionSingularityDetection != null &&
                    this.PrecisionSingularityDetection.Equals(input.PrecisionSingularityDetection))
                ) && 
                (
                    this.StopIfSingular == input.StopIfSingular ||
                    (this.StopIfSingular != null &&
                    this.StopIfSingular.Equals(input.StopIfSingular))
                ) && 
                (
                    this.EliminateLagrangeMultipliers == input.EliminateLagrangeMultipliers ||
                    (this.EliminateLagrangeMultipliers != null &&
                    this.EliminateLagrangeMultipliers.Equals(input.EliminateLagrangeMultipliers))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                hashCode = hashCode * 59 + this.RenumberingMethod.GetHashCode();
                if (this.ForceSymmetric != null)
                    hashCode = hashCode * 59 + this.ForceSymmetric.GetHashCode();
                if (this.PrecisionSingularityDetection != null)
                    hashCode = hashCode * 59 + this.PrecisionSingularityDetection.GetHashCode();
                if (this.StopIfSingular != null)
                    hashCode = hashCode * 59 + this.StopIfSingular.GetHashCode();
                if (this.EliminateLagrangeMultipliers != null)
                    hashCode = hashCode * 59 + this.EliminateLagrangeMultipliers.GetHashCode();
                return hashCode;
            }
        }

    }

}
