/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// MeshQualityControls
    /// </summary>
    [DataContract]
    public partial class MeshQualityControls : IEquatable<MeshQualityControls>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MeshQualityControls" /> class.
        /// </summary>
        /// <param name="maxNonOrthogonality">maxNonOrthogonality.</param>
        /// <param name="maxBoundarySkewness">maxBoundarySkewness.</param>
        /// <param name="maxInternalSkewness">maxInternalSkewness.</param>
        /// <param name="maxConcaveness">maxConcaveness.</param>
        /// <param name="minVolume">minVolume.</param>
        /// <param name="minTetQuality">&lt;p&gt;Define a minimum tetrahedron quality for cells (see documentation). Choose a low negative number to disable this check, e.g. -1e30.&lt;/p&gt; (default to -1000000000000000000000000000000M).</param>
        /// <param name="minFaceArea">minFaceArea.</param>
        /// <param name="minFaceTwist">&lt;p&gt;Define the minimum cosine of face twist allowed (see documentation). Set to a value smaller than -1 to disable. The value results from the dot product of the face normal and the face centre triangles normal.&lt;/p&gt; (default to 0.01M).</param>
        /// <param name="minDeterminant">&lt;p&gt;Define the minimum normalised cell determinant. Choose a value between 0 and 1. Hex corresponds to 1.&lt;/p&gt; (default to 0.001M).</param>
        /// <param name="minFaceWeight">&lt;p&gt;The face weight specifies the distribution of a face&#39;s contribution to its two neighbouring cells. A very small face weight would mean that the neighbouring cells are disproportionately different in size. Choose a value between 0 and 0.5. 0.5 refers to a face with neighbouring cells of the same size.&lt;/p&gt; (default to 0.02M).</param>
        /// <param name="minVolumeRatio">&lt;p&gt;This parameter specifies the minimum allowed volume ratio between two adjacent cells. Choose a value between 0 and 1. 1 means that the neighbouring cells have the same volume.&lt;/p&gt; (default to 0.01M).</param>
        /// <param name="minTriangleTwist">&lt;p&gt;Same as Min Face Twist, but for adjacent triangular faces (see documentation). Choose a value below -1 to disable this feature.&lt;/p&gt; (default to -1M).</param>
        /// <param name="errorDistributionIterations">&lt;p&gt;Define the number of error distribution iterations.&lt;/p&gt; (default to 4).</param>
        /// <param name="errorReduction">&lt;p&gt;This parameter specifies how much the displacement is scaled at error locations.&lt;/p&gt; (default to 0.75M).</param>
        /// <param name="relaxedMaxNonOrthogonality">relaxedMaxNonOrthogonality.</param>
        /// <param name="mergeTolerance">&lt;p&gt;This parameters specifies the accuracy of face merging as a fraction of the initial bounding box.&lt;/p&gt; (default to 0.0000010M).</param>
        public MeshQualityControls(DimensionalAngle maxNonOrthogonality = default(DimensionalAngle), DimensionalAngle maxBoundarySkewness = default(DimensionalAngle), DimensionalAngle maxInternalSkewness = default(DimensionalAngle), DimensionalAngle maxConcaveness = default(DimensionalAngle), DimensionalVolume minVolume = default(DimensionalVolume), decimal? minTetQuality = default(decimal?), DimensionalArea minFaceArea = default(DimensionalArea), decimal? minFaceTwist = default(decimal?), decimal? minDeterminant = default(decimal?), decimal? minFaceWeight = default(decimal?), decimal? minVolumeRatio = default(decimal?), decimal? minTriangleTwist = default(decimal?), int? errorDistributionIterations = default(int?), decimal? errorReduction = default(decimal?), DimensionalAngle relaxedMaxNonOrthogonality = default(DimensionalAngle), decimal? mergeTolerance = default(decimal?))
        {
            this.MaxNonOrthogonality = maxNonOrthogonality;
            this.MaxBoundarySkewness = maxBoundarySkewness;
            this.MaxInternalSkewness = maxInternalSkewness;
            this.MaxConcaveness = maxConcaveness;
            this.MinVolume = minVolume;
            this.MinTetQuality = minTetQuality;
            this.MinFaceArea = minFaceArea;
            this.MinFaceTwist = minFaceTwist;
            this.MinDeterminant = minDeterminant;
            this.MinFaceWeight = minFaceWeight;
            this.MinVolumeRatio = minVolumeRatio;
            this.MinTriangleTwist = minTriangleTwist;
            this.ErrorDistributionIterations = errorDistributionIterations;
            this.ErrorReduction = errorReduction;
            this.RelaxedMaxNonOrthogonality = relaxedMaxNonOrthogonality;
            this.MergeTolerance = mergeTolerance;
        }
        
        /// <summary>
        /// Gets or Sets MaxNonOrthogonality
        /// </summary>
        [DataMember(Name="maxNonOrthogonality", EmitDefaultValue=false)]
        public DimensionalAngle MaxNonOrthogonality { get; set; }

        /// <summary>
        /// Gets or Sets MaxBoundarySkewness
        /// </summary>
        [DataMember(Name="maxBoundarySkewness", EmitDefaultValue=false)]
        public DimensionalAngle MaxBoundarySkewness { get; set; }

        /// <summary>
        /// Gets or Sets MaxInternalSkewness
        /// </summary>
        [DataMember(Name="maxInternalSkewness", EmitDefaultValue=false)]
        public DimensionalAngle MaxInternalSkewness { get; set; }

        /// <summary>
        /// Gets or Sets MaxConcaveness
        /// </summary>
        [DataMember(Name="maxConcaveness", EmitDefaultValue=false)]
        public DimensionalAngle MaxConcaveness { get; set; }

        /// <summary>
        /// Gets or Sets MinVolume
        /// </summary>
        [DataMember(Name="minVolume", EmitDefaultValue=false)]
        public DimensionalVolume MinVolume { get; set; }

        /// <summary>
        /// &lt;p&gt;Define a minimum tetrahedron quality for cells (see documentation). Choose a low negative number to disable this check, e.g. -1e30.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Define a minimum tetrahedron quality for cells (see documentation). Choose a low negative number to disable this check, e.g. -1e30.&lt;/p&gt;</value>
        [DataMember(Name="minTetQuality", EmitDefaultValue=false)]
        public decimal? MinTetQuality { get; set; }

        /// <summary>
        /// Gets or Sets MinFaceArea
        /// </summary>
        [DataMember(Name="minFaceArea", EmitDefaultValue=false)]
        public DimensionalArea MinFaceArea { get; set; }

        /// <summary>
        /// &lt;p&gt;Define the minimum cosine of face twist allowed (see documentation). Set to a value smaller than -1 to disable. The value results from the dot product of the face normal and the face centre triangles normal.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Define the minimum cosine of face twist allowed (see documentation). Set to a value smaller than -1 to disable. The value results from the dot product of the face normal and the face centre triangles normal.&lt;/p&gt;</value>
        [DataMember(Name="minFaceTwist", EmitDefaultValue=false)]
        public decimal? MinFaceTwist { get; set; }

        /// <summary>
        /// &lt;p&gt;Define the minimum normalised cell determinant. Choose a value between 0 and 1. Hex corresponds to 1.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Define the minimum normalised cell determinant. Choose a value between 0 and 1. Hex corresponds to 1.&lt;/p&gt;</value>
        [DataMember(Name="minDeterminant", EmitDefaultValue=false)]
        public decimal? MinDeterminant { get; set; }

        /// <summary>
        /// &lt;p&gt;The face weight specifies the distribution of a face&#39;s contribution to its two neighbouring cells. A very small face weight would mean that the neighbouring cells are disproportionately different in size. Choose a value between 0 and 0.5. 0.5 refers to a face with neighbouring cells of the same size.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;The face weight specifies the distribution of a face&#39;s contribution to its two neighbouring cells. A very small face weight would mean that the neighbouring cells are disproportionately different in size. Choose a value between 0 and 0.5. 0.5 refers to a face with neighbouring cells of the same size.&lt;/p&gt;</value>
        [DataMember(Name="minFaceWeight", EmitDefaultValue=false)]
        public decimal? MinFaceWeight { get; set; }

        /// <summary>
        /// &lt;p&gt;This parameter specifies the minimum allowed volume ratio between two adjacent cells. Choose a value between 0 and 1. 1 means that the neighbouring cells have the same volume.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;This parameter specifies the minimum allowed volume ratio between two adjacent cells. Choose a value between 0 and 1. 1 means that the neighbouring cells have the same volume.&lt;/p&gt;</value>
        [DataMember(Name="minVolumeRatio", EmitDefaultValue=false)]
        public decimal? MinVolumeRatio { get; set; }

        /// <summary>
        /// &lt;p&gt;Same as Min Face Twist, but for adjacent triangular faces (see documentation). Choose a value below -1 to disable this feature.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Same as Min Face Twist, but for adjacent triangular faces (see documentation). Choose a value below -1 to disable this feature.&lt;/p&gt;</value>
        [DataMember(Name="minTriangleTwist", EmitDefaultValue=false)]
        public decimal? MinTriangleTwist { get; set; }

        /// <summary>
        /// &lt;p&gt;Define the number of error distribution iterations.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Define the number of error distribution iterations.&lt;/p&gt;</value>
        [DataMember(Name="errorDistributionIterations", EmitDefaultValue=false)]
        public int? ErrorDistributionIterations { get; set; }

        /// <summary>
        /// &lt;p&gt;This parameter specifies how much the displacement is scaled at error locations.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;This parameter specifies how much the displacement is scaled at error locations.&lt;/p&gt;</value>
        [DataMember(Name="errorReduction", EmitDefaultValue=false)]
        public decimal? ErrorReduction { get; set; }

        /// <summary>
        /// Gets or Sets RelaxedMaxNonOrthogonality
        /// </summary>
        [DataMember(Name="relaxedMaxNonOrthogonality", EmitDefaultValue=false)]
        public DimensionalAngle RelaxedMaxNonOrthogonality { get; set; }

        /// <summary>
        /// &lt;p&gt;This parameters specifies the accuracy of face merging as a fraction of the initial bounding box.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;This parameters specifies the accuracy of face merging as a fraction of the initial bounding box.&lt;/p&gt;</value>
        [DataMember(Name="mergeTolerance", EmitDefaultValue=false)]
        public decimal? MergeTolerance { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class MeshQualityControls {\n");
            sb.Append("  MaxNonOrthogonality: ").Append(MaxNonOrthogonality).Append("\n");
            sb.Append("  MaxBoundarySkewness: ").Append(MaxBoundarySkewness).Append("\n");
            sb.Append("  MaxInternalSkewness: ").Append(MaxInternalSkewness).Append("\n");
            sb.Append("  MaxConcaveness: ").Append(MaxConcaveness).Append("\n");
            sb.Append("  MinVolume: ").Append(MinVolume).Append("\n");
            sb.Append("  MinTetQuality: ").Append(MinTetQuality).Append("\n");
            sb.Append("  MinFaceArea: ").Append(MinFaceArea).Append("\n");
            sb.Append("  MinFaceTwist: ").Append(MinFaceTwist).Append("\n");
            sb.Append("  MinDeterminant: ").Append(MinDeterminant).Append("\n");
            sb.Append("  MinFaceWeight: ").Append(MinFaceWeight).Append("\n");
            sb.Append("  MinVolumeRatio: ").Append(MinVolumeRatio).Append("\n");
            sb.Append("  MinTriangleTwist: ").Append(MinTriangleTwist).Append("\n");
            sb.Append("  ErrorDistributionIterations: ").Append(ErrorDistributionIterations).Append("\n");
            sb.Append("  ErrorReduction: ").Append(ErrorReduction).Append("\n");
            sb.Append("  RelaxedMaxNonOrthogonality: ").Append(RelaxedMaxNonOrthogonality).Append("\n");
            sb.Append("  MergeTolerance: ").Append(MergeTolerance).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MeshQualityControls);
        }

        /// <summary>
        /// Returns true if MeshQualityControls instances are equal
        /// </summary>
        /// <param name="input">Instance of MeshQualityControls to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MeshQualityControls input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.MaxNonOrthogonality == input.MaxNonOrthogonality ||
                    (this.MaxNonOrthogonality != null &&
                    this.MaxNonOrthogonality.Equals(input.MaxNonOrthogonality))
                ) && 
                (
                    this.MaxBoundarySkewness == input.MaxBoundarySkewness ||
                    (this.MaxBoundarySkewness != null &&
                    this.MaxBoundarySkewness.Equals(input.MaxBoundarySkewness))
                ) && 
                (
                    this.MaxInternalSkewness == input.MaxInternalSkewness ||
                    (this.MaxInternalSkewness != null &&
                    this.MaxInternalSkewness.Equals(input.MaxInternalSkewness))
                ) && 
                (
                    this.MaxConcaveness == input.MaxConcaveness ||
                    (this.MaxConcaveness != null &&
                    this.MaxConcaveness.Equals(input.MaxConcaveness))
                ) && 
                (
                    this.MinVolume == input.MinVolume ||
                    (this.MinVolume != null &&
                    this.MinVolume.Equals(input.MinVolume))
                ) && 
                (
                    this.MinTetQuality == input.MinTetQuality ||
                    (this.MinTetQuality != null &&
                    this.MinTetQuality.Equals(input.MinTetQuality))
                ) && 
                (
                    this.MinFaceArea == input.MinFaceArea ||
                    (this.MinFaceArea != null &&
                    this.MinFaceArea.Equals(input.MinFaceArea))
                ) && 
                (
                    this.MinFaceTwist == input.MinFaceTwist ||
                    (this.MinFaceTwist != null &&
                    this.MinFaceTwist.Equals(input.MinFaceTwist))
                ) && 
                (
                    this.MinDeterminant == input.MinDeterminant ||
                    (this.MinDeterminant != null &&
                    this.MinDeterminant.Equals(input.MinDeterminant))
                ) && 
                (
                    this.MinFaceWeight == input.MinFaceWeight ||
                    (this.MinFaceWeight != null &&
                    this.MinFaceWeight.Equals(input.MinFaceWeight))
                ) && 
                (
                    this.MinVolumeRatio == input.MinVolumeRatio ||
                    (this.MinVolumeRatio != null &&
                    this.MinVolumeRatio.Equals(input.MinVolumeRatio))
                ) && 
                (
                    this.MinTriangleTwist == input.MinTriangleTwist ||
                    (this.MinTriangleTwist != null &&
                    this.MinTriangleTwist.Equals(input.MinTriangleTwist))
                ) && 
                (
                    this.ErrorDistributionIterations == input.ErrorDistributionIterations ||
                    (this.ErrorDistributionIterations != null &&
                    this.ErrorDistributionIterations.Equals(input.ErrorDistributionIterations))
                ) && 
                (
                    this.ErrorReduction == input.ErrorReduction ||
                    (this.ErrorReduction != null &&
                    this.ErrorReduction.Equals(input.ErrorReduction))
                ) && 
                (
                    this.RelaxedMaxNonOrthogonality == input.RelaxedMaxNonOrthogonality ||
                    (this.RelaxedMaxNonOrthogonality != null &&
                    this.RelaxedMaxNonOrthogonality.Equals(input.RelaxedMaxNonOrthogonality))
                ) && 
                (
                    this.MergeTolerance == input.MergeTolerance ||
                    (this.MergeTolerance != null &&
                    this.MergeTolerance.Equals(input.MergeTolerance))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.MaxNonOrthogonality != null)
                    hashCode = hashCode * 59 + this.MaxNonOrthogonality.GetHashCode();
                if (this.MaxBoundarySkewness != null)
                    hashCode = hashCode * 59 + this.MaxBoundarySkewness.GetHashCode();
                if (this.MaxInternalSkewness != null)
                    hashCode = hashCode * 59 + this.MaxInternalSkewness.GetHashCode();
                if (this.MaxConcaveness != null)
                    hashCode = hashCode * 59 + this.MaxConcaveness.GetHashCode();
                if (this.MinVolume != null)
                    hashCode = hashCode * 59 + this.MinVolume.GetHashCode();
                if (this.MinTetQuality != null)
                    hashCode = hashCode * 59 + this.MinTetQuality.GetHashCode();
                if (this.MinFaceArea != null)
                    hashCode = hashCode * 59 + this.MinFaceArea.GetHashCode();
                if (this.MinFaceTwist != null)
                    hashCode = hashCode * 59 + this.MinFaceTwist.GetHashCode();
                if (this.MinDeterminant != null)
                    hashCode = hashCode * 59 + this.MinDeterminant.GetHashCode();
                if (this.MinFaceWeight != null)
                    hashCode = hashCode * 59 + this.MinFaceWeight.GetHashCode();
                if (this.MinVolumeRatio != null)
                    hashCode = hashCode * 59 + this.MinVolumeRatio.GetHashCode();
                if (this.MinTriangleTwist != null)
                    hashCode = hashCode * 59 + this.MinTriangleTwist.GetHashCode();
                if (this.ErrorDistributionIterations != null)
                    hashCode = hashCode * 59 + this.ErrorDistributionIterations.GetHashCode();
                if (this.ErrorReduction != null)
                    hashCode = hashCode * 59 + this.ErrorReduction.GetHashCode();
                if (this.RelaxedMaxNonOrthogonality != null)
                    hashCode = hashCode * 59 + this.RelaxedMaxNonOrthogonality.GetHashCode();
                if (this.MergeTolerance != null)
                    hashCode = hashCode * 59 + this.MergeTolerance.GetHashCode();
                return hashCode;
            }
        }

    }

}
