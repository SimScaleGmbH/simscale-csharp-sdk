/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// MUMPSPreconditoner
    /// </summary>
    [DataContract]
    public partial class MUMPSPreconditoner : OneOfGCPCSolverPreconditioner, OneOfPETSCSolverPreconditioner, IEquatable<MUMPSPreconditoner>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MUMPSPreconditoner" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected MUMPSPreconditoner() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="MUMPSPreconditoner" /> class.
        /// </summary>
        /// <param name="type">type (required) (default to &quot;MUMPS_LDLT&quot;).</param>
        /// <param name="actualisationRate">Set the reactualisation intervall for the preconditioner matrix P. If this value is set to 30 the preconditioner is recomputed just every 30th iteration. This preconditioner is computionally more expensive than the incomplete LDLT factorization but nearer to the exact solution. This setting makes it possible to save computation time by taking advantage of this fact. (default to 30).</param>
        /// <param name="memoryPercentageForPivoting">Define how much additional memory should be reserved for the pivoting operations. If MUMPS estimates that the necessary space for factorising the matrix would be 100, choosing a value of 20 would mean that MUMPS allocates a memory space of 120. (default to 20M).</param>
        public MUMPSPreconditoner(string type = "MUMPS_LDLT", int? actualisationRate = default(int?), decimal? memoryPercentageForPivoting = default(decimal?))
        {
            // to ensure "type" is required (not null)
            this.Type = type ?? throw new ArgumentNullException("type is a required property for MUMPSPreconditoner and cannot be null");
            this.ActualisationRate = actualisationRate;
            this.MemoryPercentageForPivoting = memoryPercentageForPivoting;
        }
        
        /// <summary>
        /// Gets or Sets Type
        /// </summary>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public string Type { get; set; }

        /// <summary>
        /// Set the reactualisation intervall for the preconditioner matrix P. If this value is set to 30 the preconditioner is recomputed just every 30th iteration. This preconditioner is computionally more expensive than the incomplete LDLT factorization but nearer to the exact solution. This setting makes it possible to save computation time by taking advantage of this fact.
        /// </summary>
        /// <value>Set the reactualisation intervall for the preconditioner matrix P. If this value is set to 30 the preconditioner is recomputed just every 30th iteration. This preconditioner is computionally more expensive than the incomplete LDLT factorization but nearer to the exact solution. This setting makes it possible to save computation time by taking advantage of this fact.</value>
        [DataMember(Name="actualisationRate", EmitDefaultValue=false)]
        public int? ActualisationRate { get; set; }

        /// <summary>
        /// Define how much additional memory should be reserved for the pivoting operations. If MUMPS estimates that the necessary space for factorising the matrix would be 100, choosing a value of 20 would mean that MUMPS allocates a memory space of 120.
        /// </summary>
        /// <value>Define how much additional memory should be reserved for the pivoting operations. If MUMPS estimates that the necessary space for factorising the matrix would be 100, choosing a value of 20 would mean that MUMPS allocates a memory space of 120.</value>
        [DataMember(Name="memoryPercentageForPivoting", EmitDefaultValue=false)]
        public decimal? MemoryPercentageForPivoting { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class MUMPSPreconditoner {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  ActualisationRate: ").Append(ActualisationRate).Append("\n");
            sb.Append("  MemoryPercentageForPivoting: ").Append(MemoryPercentageForPivoting).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as MUMPSPreconditoner);
        }

        /// <summary>
        /// Returns true if MUMPSPreconditoner instances are equal
        /// </summary>
        /// <param name="input">Instance of MUMPSPreconditoner to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(MUMPSPreconditoner input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.ActualisationRate == input.ActualisationRate ||
                    (this.ActualisationRate != null &&
                    this.ActualisationRate.Equals(input.ActualisationRate))
                ) && 
                (
                    this.MemoryPercentageForPivoting == input.MemoryPercentageForPivoting ||
                    (this.MemoryPercentageForPivoting != null &&
                    this.MemoryPercentageForPivoting.Equals(input.MemoryPercentageForPivoting))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.ActualisationRate != null)
                    hashCode = hashCode * 59 + this.ActualisationRate.GetHashCode();
                if (this.MemoryPercentageForPivoting != null)
                    hashCode = hashCode * 59 + this.MemoryPercentageForPivoting.GetHashCode();
                return hashCode;
            }
        }

    }

}
