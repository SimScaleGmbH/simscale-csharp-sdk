/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// &lt;p&gt;The &lt;b&gt;cyclic symmetry&lt;/b&gt; constraint enables to model only a sector of a 360째 cyclic periodic structure and reduces the computation time and memory consumption considerably. The user defines the center and axis of the cyclic symmetry as well as the sector angle. The &lt;b&gt;master&lt;/b&gt; and &lt;b&gt;slave&lt;/b&gt; surfaces define the cyclic periodicity boundaries. &lt;br /&gt;&lt;br /&gt;Important remarks: &lt;br /&gt;&lt;ul&gt;&lt;li&gt;All DOFs of the slave nodes will be constrained, adding an additional constraint on those nodes may lead to an overconstrained system.&lt;/li&gt;&lt;li&gt;This is a &lt;b&gt;linear&lt;/b&gt; constraint, so no large rotations or large deformations are allowed in the proximity of cyclic symmetry boundaries.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;img src&#x3D;\&quot;/spec/resources/help/imgs/cyclic_symmetry.png\&quot; class&#x3D;\&quot;helpPopupImage\&quot;/&gt; &lt;a href&#x3D;&#39;https://www.simscale.com/knowledge-base/how-to-apply-cyclic-symmetry-fea&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;
    /// </summary>
    [DataContract]
    public partial class CyclicSymmetryBC : OneOfDynamicAnalysisBoundaryConditions, OneOfHarmonicAnalysisBoundaryConditions, OneOfHeatTransferBoundaryConditions, OneOfStaticAnalysisBoundaryConditions, OneOfThermalMechanicalBoundaryConditions, IEquatable<CyclicSymmetryBC>
    {
        /// <summary>
        /// &lt;p&gt;Define if heat transfer should be allowed across the contact. If &lt;b&gt;yes&lt;/b&gt; is chosen a perfectly bonded heat contact is assumed whereas if &lt;b&gt;no&lt;/b&gt; is selected no heat transfer across the contact is allowed. Mechanical contact stays with both options active. With the selection of &lt;b&gt;heat transfer only&lt;/b&gt; no mechanical contact is activated but only a bonded heat contact.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Define if heat transfer should be allowed across the contact. If &lt;b&gt;yes&lt;/b&gt; is chosen a perfectly bonded heat contact is assumed whereas if &lt;b&gt;no&lt;/b&gt; is selected no heat transfer across the contact is allowed. Mechanical contact stays with both options active. With the selection of &lt;b&gt;heat transfer only&lt;/b&gt; no mechanical contact is activated but only a bonded heat contact.&lt;/p&gt;</value>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum EnableHeatTransferEnum
        {
            /// <summary>
            /// Enum YES for value: YES
            /// </summary>
            [EnumMember(Value = "YES")]
            YES = 1,

            /// <summary>
            /// Enum NO for value: NO
            /// </summary>
            [EnumMember(Value = "NO")]
            NO = 2,

            /// <summary>
            /// Enum HEATTRANSFERONLY for value: HEAT_TRANSFER_ONLY
            /// </summary>
            [EnumMember(Value = "HEAT_TRANSFER_ONLY")]
            HEATTRANSFERONLY = 3

        }

        /// <summary>
        /// &lt;p&gt;Define if heat transfer should be allowed across the contact. If &lt;b&gt;yes&lt;/b&gt; is chosen a perfectly bonded heat contact is assumed whereas if &lt;b&gt;no&lt;/b&gt; is selected no heat transfer across the contact is allowed. Mechanical contact stays with both options active. With the selection of &lt;b&gt;heat transfer only&lt;/b&gt; no mechanical contact is activated but only a bonded heat contact.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Define if heat transfer should be allowed across the contact. If &lt;b&gt;yes&lt;/b&gt; is chosen a perfectly bonded heat contact is assumed whereas if &lt;b&gt;no&lt;/b&gt; is selected no heat transfer across the contact is allowed. Mechanical contact stays with both options active. With the selection of &lt;b&gt;heat transfer only&lt;/b&gt; no mechanical contact is activated but only a bonded heat contact.&lt;/p&gt;</value>
        [DataMember(Name="enableHeatTransfer", EmitDefaultValue=false)]
        public EnableHeatTransferEnum? EnableHeatTransfer { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="CyclicSymmetryBC" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected CyclicSymmetryBC() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="CyclicSymmetryBC" /> class.
        /// </summary>
        /// <param name="type">&lt;p&gt;The &lt;b&gt;cyclic symmetry&lt;/b&gt; constraint enables to model only a sector of a 360째 cyclic periodic structure and reduces the computation time and memory consumption considerably. The user defines the center and axis of the cyclic symmetry as well as the sector angle. The &lt;b&gt;master&lt;/b&gt; and &lt;b&gt;slave&lt;/b&gt; surfaces define the cyclic periodicity boundaries. &lt;br /&gt;&lt;br /&gt;Important remarks: &lt;br /&gt;&lt;ul&gt;&lt;li&gt;All DOFs of the slave nodes will be constrained, adding an additional constraint on those nodes may lead to an overconstrained system.&lt;/li&gt;&lt;li&gt;This is a &lt;b&gt;linear&lt;/b&gt; constraint, so no large rotations or large deformations are allowed in the proximity of cyclic symmetry boundaries.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;img src&#x3D;\&quot;/spec/resources/help/imgs/cyclic_symmetry.png\&quot; class&#x3D;\&quot;helpPopupImage\&quot;/&gt; &lt;a href&#x3D;&#39;https://www.simscale.com/knowledge-base/how-to-apply-cyclic-symmetry-fea&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;  Schema name: CyclicSymmetryBC (required) (default to &quot;CYCLIC_SYMMETRY&quot;).</param>
        /// <param name="name">name.</param>
        /// <param name="enableHeatTransfer">&lt;p&gt;Define if heat transfer should be allowed across the contact. If &lt;b&gt;yes&lt;/b&gt; is chosen a perfectly bonded heat contact is assumed whereas if &lt;b&gt;no&lt;/b&gt; is selected no heat transfer across the contact is allowed. Mechanical contact stays with both options active. With the selection of &lt;b&gt;heat transfer only&lt;/b&gt; no mechanical contact is activated but only a bonded heat contact.&lt;/p&gt; (default to EnableHeatTransferEnum.YES).</param>
        /// <param name="axisOrigin">axisOrigin.</param>
        /// <param name="axisDirection">axisDirection.</param>
        /// <param name="sectorAngle">sectorAngle.</param>
        /// <param name="masterTopologicalReference">masterTopologicalReference.</param>
        /// <param name="slaveTopologicalReference">slaveTopologicalReference.</param>
        public CyclicSymmetryBC(string type = "CYCLIC_SYMMETRY", string name = default(string), EnableHeatTransferEnum? enableHeatTransfer = default(EnableHeatTransferEnum?), DimensionalVectorLength axisOrigin = default(DimensionalVectorLength), DimensionalVectorLength axisDirection = default(DimensionalVectorLength), DimensionalAngle sectorAngle = default(DimensionalAngle), TopologicalReference masterTopologicalReference = default(TopologicalReference), TopologicalReference slaveTopologicalReference = default(TopologicalReference))
        {
            // to ensure "type" is required (not null)
            this.Type = type ?? throw new ArgumentNullException("type is a required property for CyclicSymmetryBC and cannot be null");
            this.Name = name;
            this.EnableHeatTransfer = enableHeatTransfer;
            this.AxisOrigin = axisOrigin;
            this.AxisDirection = axisDirection;
            this.SectorAngle = sectorAngle;
            this.MasterTopologicalReference = masterTopologicalReference;
            this.SlaveTopologicalReference = slaveTopologicalReference;
        }
        
        /// <summary>
        /// &lt;p&gt;The &lt;b&gt;cyclic symmetry&lt;/b&gt; constraint enables to model only a sector of a 360째 cyclic periodic structure and reduces the computation time and memory consumption considerably. The user defines the center and axis of the cyclic symmetry as well as the sector angle. The &lt;b&gt;master&lt;/b&gt; and &lt;b&gt;slave&lt;/b&gt; surfaces define the cyclic periodicity boundaries. &lt;br /&gt;&lt;br /&gt;Important remarks: &lt;br /&gt;&lt;ul&gt;&lt;li&gt;All DOFs of the slave nodes will be constrained, adding an additional constraint on those nodes may lead to an overconstrained system.&lt;/li&gt;&lt;li&gt;This is a &lt;b&gt;linear&lt;/b&gt; constraint, so no large rotations or large deformations are allowed in the proximity of cyclic symmetry boundaries.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;img src&#x3D;\&quot;/spec/resources/help/imgs/cyclic_symmetry.png\&quot; class&#x3D;\&quot;helpPopupImage\&quot;/&gt; &lt;a href&#x3D;&#39;https://www.simscale.com/knowledge-base/how-to-apply-cyclic-symmetry-fea&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;  Schema name: CyclicSymmetryBC
        /// </summary>
        /// <value>&lt;p&gt;The &lt;b&gt;cyclic symmetry&lt;/b&gt; constraint enables to model only a sector of a 360째 cyclic periodic structure and reduces the computation time and memory consumption considerably. The user defines the center and axis of the cyclic symmetry as well as the sector angle. The &lt;b&gt;master&lt;/b&gt; and &lt;b&gt;slave&lt;/b&gt; surfaces define the cyclic periodicity boundaries. &lt;br /&gt;&lt;br /&gt;Important remarks: &lt;br /&gt;&lt;ul&gt;&lt;li&gt;All DOFs of the slave nodes will be constrained, adding an additional constraint on those nodes may lead to an overconstrained system.&lt;/li&gt;&lt;li&gt;This is a &lt;b&gt;linear&lt;/b&gt; constraint, so no large rotations or large deformations are allowed in the proximity of cyclic symmetry boundaries.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;img src&#x3D;\&quot;/spec/resources/help/imgs/cyclic_symmetry.png\&quot; class&#x3D;\&quot;helpPopupImage\&quot;/&gt; &lt;a href&#x3D;&#39;https://www.simscale.com/knowledge-base/how-to-apply-cyclic-symmetry-fea&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;  Schema name: CyclicSymmetryBC</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public string Type { get; set; }

        /// <summary>
        /// Gets or Sets Name
        /// </summary>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// Gets or Sets AxisOrigin
        /// </summary>
        [DataMember(Name="axisOrigin", EmitDefaultValue=false)]
        public DimensionalVectorLength AxisOrigin { get; set; }

        /// <summary>
        /// Gets or Sets AxisDirection
        /// </summary>
        [DataMember(Name="axisDirection", EmitDefaultValue=false)]
        public DimensionalVectorLength AxisDirection { get; set; }

        /// <summary>
        /// Gets or Sets SectorAngle
        /// </summary>
        [DataMember(Name="sectorAngle", EmitDefaultValue=false)]
        public DimensionalAngle SectorAngle { get; set; }

        /// <summary>
        /// Gets or Sets MasterTopologicalReference
        /// </summary>
        [DataMember(Name="masterTopologicalReference", EmitDefaultValue=false)]
        public TopologicalReference MasterTopologicalReference { get; set; }

        /// <summary>
        /// Gets or Sets SlaveTopologicalReference
        /// </summary>
        [DataMember(Name="slaveTopologicalReference", EmitDefaultValue=false)]
        public TopologicalReference SlaveTopologicalReference { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class CyclicSymmetryBC {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  EnableHeatTransfer: ").Append(EnableHeatTransfer).Append("\n");
            sb.Append("  AxisOrigin: ").Append(AxisOrigin).Append("\n");
            sb.Append("  AxisDirection: ").Append(AxisDirection).Append("\n");
            sb.Append("  SectorAngle: ").Append(SectorAngle).Append("\n");
            sb.Append("  MasterTopologicalReference: ").Append(MasterTopologicalReference).Append("\n");
            sb.Append("  SlaveTopologicalReference: ").Append(SlaveTopologicalReference).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CyclicSymmetryBC);
        }

        /// <summary>
        /// Returns true if CyclicSymmetryBC instances are equal
        /// </summary>
        /// <param name="input">Instance of CyclicSymmetryBC to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CyclicSymmetryBC input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.EnableHeatTransfer == input.EnableHeatTransfer ||
                    this.EnableHeatTransfer.Equals(input.EnableHeatTransfer)
                ) && 
                (
                    this.AxisOrigin == input.AxisOrigin ||
                    (this.AxisOrigin != null &&
                    this.AxisOrigin.Equals(input.AxisOrigin))
                ) && 
                (
                    this.AxisDirection == input.AxisDirection ||
                    (this.AxisDirection != null &&
                    this.AxisDirection.Equals(input.AxisDirection))
                ) && 
                (
                    this.SectorAngle == input.SectorAngle ||
                    (this.SectorAngle != null &&
                    this.SectorAngle.Equals(input.SectorAngle))
                ) && 
                (
                    this.MasterTopologicalReference == input.MasterTopologicalReference ||
                    (this.MasterTopologicalReference != null &&
                    this.MasterTopologicalReference.Equals(input.MasterTopologicalReference))
                ) && 
                (
                    this.SlaveTopologicalReference == input.SlaveTopologicalReference ||
                    (this.SlaveTopologicalReference != null &&
                    this.SlaveTopologicalReference.Equals(input.SlaveTopologicalReference))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                hashCode = hashCode * 59 + this.EnableHeatTransfer.GetHashCode();
                if (this.AxisOrigin != null)
                    hashCode = hashCode * 59 + this.AxisOrigin.GetHashCode();
                if (this.AxisDirection != null)
                    hashCode = hashCode * 59 + this.AxisDirection.GetHashCode();
                if (this.SectorAngle != null)
                    hashCode = hashCode * 59 + this.SectorAngle.GetHashCode();
                if (this.MasterTopologicalReference != null)
                    hashCode = hashCode * 59 + this.MasterTopologicalReference.GetHashCode();
                if (this.SlaveTopologicalReference != null)
                    hashCode = hashCode * 59 + this.SlaveTopologicalReference.GetHashCode();
                return hashCode;
            }
        }

    }

}
