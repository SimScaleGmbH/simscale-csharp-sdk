/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// CastellatedMeshControls
    /// </summary>
    [DataContract]
    public partial class CastellatedMeshControls : IEquatable<CastellatedMeshControls>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CastellatedMeshControls" /> class.
        /// </summary>
        /// <param name="maxLocalCells">&lt;p&gt;Define the maximal number of cells per processor during refinement&lt;/p&gt; (default to 40000000).</param>
        /// <param name="maxGlobalCells">&lt;p&gt;Define the maximum possible number of cells summed upon all processors. Note that this is before the castellation step (see documentation, so the actual number of cells after castellation might be considerably less.&lt;/p&gt; (default to 100000000).</param>
        /// <param name="minRefinementCells">&lt;p&gt;If in a refinement iteration the number of cells selected for refinement is under this value, the refinement stops. Provide a small value to ensure that all surfaces are refined to the proper level.&lt;/p&gt; (default to 1).</param>
        /// <param name="maxLoadUnbalance">&lt;p&gt;Define a fraction indicating the maximum allowable load imbalance between processors working on this job. A value of 0 will force rebalancing for even a slight imbalance.&lt;/p&gt; (default to 0.2M).</param>
        /// <param name="cellsBetweenLevels">&lt;p&gt;This parameter specifies the number of layers of cells between different levels of refinement (see documentation).&lt;/p&gt; (default to 3).</param>
        /// <param name="resolveFeatureAngle">&lt;p&gt;Cells that face multiple intersections with an intersection angle greater than this angle will be refined to the max level. Use this parameter to resolve sharp features to the maximum level of surface refinement specified (see documentation).&lt;/p&gt; (default to 30M).</param>
        /// <param name="allowFreeStandingZoneFaces">&lt;p&gt;Decide whether you want to allow zone faces that share the same owner and neighbour cell zone. Allowing this can lead to problem when zone faces are snapped to features. This parameter is ignored when no faceZones are present.&lt;/p&gt; (default to false).</param>
        public CastellatedMeshControls(int? maxLocalCells = default(int?), int? maxGlobalCells = default(int?), int? minRefinementCells = default(int?), decimal? maxLoadUnbalance = default(decimal?), int? cellsBetweenLevels = default(int?), decimal? resolveFeatureAngle = default(decimal?), bool? allowFreeStandingZoneFaces = default(bool?))
        {
            this.MaxLocalCells = maxLocalCells;
            this.MaxGlobalCells = maxGlobalCells;
            this.MinRefinementCells = minRefinementCells;
            this.MaxLoadUnbalance = maxLoadUnbalance;
            this.CellsBetweenLevels = cellsBetweenLevels;
            this.ResolveFeatureAngle = resolveFeatureAngle;
            this.AllowFreeStandingZoneFaces = allowFreeStandingZoneFaces;
        }
        
        /// <summary>
        /// &lt;p&gt;Define the maximal number of cells per processor during refinement&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Define the maximal number of cells per processor during refinement&lt;/p&gt;</value>
        [DataMember(Name="maxLocalCells", EmitDefaultValue=false)]
        public int? MaxLocalCells { get; set; }

        /// <summary>
        /// &lt;p&gt;Define the maximum possible number of cells summed upon all processors. Note that this is before the castellation step (see documentation, so the actual number of cells after castellation might be considerably less.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Define the maximum possible number of cells summed upon all processors. Note that this is before the castellation step (see documentation, so the actual number of cells after castellation might be considerably less.&lt;/p&gt;</value>
        [DataMember(Name="maxGlobalCells", EmitDefaultValue=false)]
        public int? MaxGlobalCells { get; set; }

        /// <summary>
        /// &lt;p&gt;If in a refinement iteration the number of cells selected for refinement is under this value, the refinement stops. Provide a small value to ensure that all surfaces are refined to the proper level.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;If in a refinement iteration the number of cells selected for refinement is under this value, the refinement stops. Provide a small value to ensure that all surfaces are refined to the proper level.&lt;/p&gt;</value>
        [DataMember(Name="minRefinementCells", EmitDefaultValue=false)]
        public int? MinRefinementCells { get; set; }

        /// <summary>
        /// &lt;p&gt;Define a fraction indicating the maximum allowable load imbalance between processors working on this job. A value of 0 will force rebalancing for even a slight imbalance.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Define a fraction indicating the maximum allowable load imbalance between processors working on this job. A value of 0 will force rebalancing for even a slight imbalance.&lt;/p&gt;</value>
        [DataMember(Name="maxLoadUnbalance", EmitDefaultValue=false)]
        public decimal? MaxLoadUnbalance { get; set; }

        /// <summary>
        /// &lt;p&gt;This parameter specifies the number of layers of cells between different levels of refinement (see documentation).&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;This parameter specifies the number of layers of cells between different levels of refinement (see documentation).&lt;/p&gt;</value>
        [DataMember(Name="cellsBetweenLevels", EmitDefaultValue=false)]
        public int? CellsBetweenLevels { get; set; }

        /// <summary>
        /// &lt;p&gt;Cells that face multiple intersections with an intersection angle greater than this angle will be refined to the max level. Use this parameter to resolve sharp features to the maximum level of surface refinement specified (see documentation).&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Cells that face multiple intersections with an intersection angle greater than this angle will be refined to the max level. Use this parameter to resolve sharp features to the maximum level of surface refinement specified (see documentation).&lt;/p&gt;</value>
        [DataMember(Name="resolveFeatureAngle", EmitDefaultValue=false)]
        public decimal? ResolveFeatureAngle { get; set; }

        /// <summary>
        /// &lt;p&gt;Decide whether you want to allow zone faces that share the same owner and neighbour cell zone. Allowing this can lead to problem when zone faces are snapped to features. This parameter is ignored when no faceZones are present.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Decide whether you want to allow zone faces that share the same owner and neighbour cell zone. Allowing this can lead to problem when zone faces are snapped to features. This parameter is ignored when no faceZones are present.&lt;/p&gt;</value>
        [DataMember(Name="allowFreeStandingZoneFaces", EmitDefaultValue=false)]
        public bool? AllowFreeStandingZoneFaces { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class CastellatedMeshControls {\n");
            sb.Append("  MaxLocalCells: ").Append(MaxLocalCells).Append("\n");
            sb.Append("  MaxGlobalCells: ").Append(MaxGlobalCells).Append("\n");
            sb.Append("  MinRefinementCells: ").Append(MinRefinementCells).Append("\n");
            sb.Append("  MaxLoadUnbalance: ").Append(MaxLoadUnbalance).Append("\n");
            sb.Append("  CellsBetweenLevels: ").Append(CellsBetweenLevels).Append("\n");
            sb.Append("  ResolveFeatureAngle: ").Append(ResolveFeatureAngle).Append("\n");
            sb.Append("  AllowFreeStandingZoneFaces: ").Append(AllowFreeStandingZoneFaces).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as CastellatedMeshControls);
        }

        /// <summary>
        /// Returns true if CastellatedMeshControls instances are equal
        /// </summary>
        /// <param name="input">Instance of CastellatedMeshControls to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(CastellatedMeshControls input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.MaxLocalCells == input.MaxLocalCells ||
                    (this.MaxLocalCells != null &&
                    this.MaxLocalCells.Equals(input.MaxLocalCells))
                ) && 
                (
                    this.MaxGlobalCells == input.MaxGlobalCells ||
                    (this.MaxGlobalCells != null &&
                    this.MaxGlobalCells.Equals(input.MaxGlobalCells))
                ) && 
                (
                    this.MinRefinementCells == input.MinRefinementCells ||
                    (this.MinRefinementCells != null &&
                    this.MinRefinementCells.Equals(input.MinRefinementCells))
                ) && 
                (
                    this.MaxLoadUnbalance == input.MaxLoadUnbalance ||
                    (this.MaxLoadUnbalance != null &&
                    this.MaxLoadUnbalance.Equals(input.MaxLoadUnbalance))
                ) && 
                (
                    this.CellsBetweenLevels == input.CellsBetweenLevels ||
                    (this.CellsBetweenLevels != null &&
                    this.CellsBetweenLevels.Equals(input.CellsBetweenLevels))
                ) && 
                (
                    this.ResolveFeatureAngle == input.ResolveFeatureAngle ||
                    (this.ResolveFeatureAngle != null &&
                    this.ResolveFeatureAngle.Equals(input.ResolveFeatureAngle))
                ) && 
                (
                    this.AllowFreeStandingZoneFaces == input.AllowFreeStandingZoneFaces ||
                    (this.AllowFreeStandingZoneFaces != null &&
                    this.AllowFreeStandingZoneFaces.Equals(input.AllowFreeStandingZoneFaces))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.MaxLocalCells != null)
                    hashCode = hashCode * 59 + this.MaxLocalCells.GetHashCode();
                if (this.MaxGlobalCells != null)
                    hashCode = hashCode * 59 + this.MaxGlobalCells.GetHashCode();
                if (this.MinRefinementCells != null)
                    hashCode = hashCode * 59 + this.MinRefinementCells.GetHashCode();
                if (this.MaxLoadUnbalance != null)
                    hashCode = hashCode * 59 + this.MaxLoadUnbalance.GetHashCode();
                if (this.CellsBetweenLevels != null)
                    hashCode = hashCode * 59 + this.CellsBetweenLevels.GetHashCode();
                if (this.ResolveFeatureAngle != null)
                    hashCode = hashCode * 59 + this.ResolveFeatureAngle.GetHashCode();
                if (this.AllowFreeStandingZoneFaces != null)
                    hashCode = hashCode * 59 + this.AllowFreeStandingZoneFaces.GetHashCode();
                return hashCode;
            }
        }

    }

}
