/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// FluidSimulationControl
    /// </summary>
    [DataContract]
    public partial class FluidSimulationControl : IEquatable<FluidSimulationControl>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FluidSimulationControl" /> class.
        /// </summary>
        /// <param name="endTime">endTime.</param>
        /// <param name="adjointEndTime">adjointEndTime.</param>
        /// <param name="numberOfIterations">This represents the total number of iterations at which the simulation will terminate. No further iterations will be performed beyond this point. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/simulation-control/&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;..</param>
        /// <param name="deltaT">deltaT.</param>
        /// <param name="variableDeltaT">variableDeltaT.</param>
        /// <param name="adjustableTimestep">adjustableTimestep.</param>
        /// <param name="writeControl">writeControl.</param>
        /// <param name="relativeConvergenceCriteria">&lt;b&gt;Steady-state simulation:&lt;/b&gt; This represents the relative error residuals that once attained by the solver the simulation is considered to be converged and will stop. The recommended value is 0.001.&lt;br&gt; &lt;b&gt;Transient simulation:&lt;/b&gt; This represents the relative error residuals that once attained by the solver the simulation will move to the next time-step regardless of the &lt;i&gt;Number of iterations&lt;/i&gt;. The recommended value is 0.1.&lt;/br&gt; &lt;br&gt; &lt;b&gt;Please note: &lt;/b&gt;Relative residual is defined as the residual in the current iteration divided by the maximum value of residual calculated up to that point.&lt;/br&gt; &lt;br&gt; &lt;b&gt;Please note: &lt;/b&gt;Lower convergence criterion is demanded for &lt;b&gt;Steady-state simulations&lt;/b&gt; because the initial guess is typically farther from the correct solution.&lt;/br&gt;.</param>
        /// <param name="numProcessors">&lt;p&gt;Selecting more processor cores will speed up the simulation process. Choosing a smaller computation instance will save core hours. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/simulation-control-fluid/#number-of-processors&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt; (default to -1).</param>
        /// <param name="maxRunTime">maxRunTime.</param>
        /// <param name="velocityScaling">&lt;p&gt;It affects the stability of the simulation. The default value of 0.1 is a good compromise between accuracy and computational requirements. Lower values of this parameter might increase the stability of the simulation at the cost of higher computational time.&lt;/p&gt; (default to 0.1M).</param>
        /// <param name="potentialFoamInitialization">This setting activates the solution of a potential flow field. The potential flow is used as initial condition for the actual simulation. This can accelerate convergence and improve stability during the first time steps. If you experience stability problems, this setting may bring some improvement. (default to false).</param>
        /// <param name="decomposeAlgorithm">decomposeAlgorithm.</param>
        public FluidSimulationControl(DimensionalTime endTime = default(DimensionalTime), DimensionalTime adjointEndTime = default(DimensionalTime), int? numberOfIterations = default(int?), DimensionalTime deltaT = default(DimensionalTime), DimensionalFunctionTime variableDeltaT = default(DimensionalFunctionTime), OneOfFluidSimulationControlAdjustableTimestep adjustableTimestep = default(OneOfFluidSimulationControlAdjustableTimestep), OneOfFluidSimulationControlWriteControl writeControl = default(OneOfFluidSimulationControlWriteControl), decimal? relativeConvergenceCriteria = default(decimal?), int? numProcessors = default(int?), DimensionalTime maxRunTime = default(DimensionalTime), decimal? velocityScaling = default(decimal?), bool? potentialFoamInitialization = default(bool?), OneOfFluidSimulationControlDecomposeAlgorithm decomposeAlgorithm = default(OneOfFluidSimulationControlDecomposeAlgorithm))
        {
            this.EndTime = endTime;
            this.AdjointEndTime = adjointEndTime;
            this.NumberOfIterations = numberOfIterations;
            this.DeltaT = deltaT;
            this.VariableDeltaT = variableDeltaT;
            this.AdjustableTimestep = adjustableTimestep;
            this.WriteControl = writeControl;
            this.RelativeConvergenceCriteria = relativeConvergenceCriteria;
            this.NumProcessors = numProcessors;
            this.MaxRunTime = maxRunTime;
            this.VelocityScaling = velocityScaling;
            this.PotentialFoamInitialization = potentialFoamInitialization;
            this.DecomposeAlgorithm = decomposeAlgorithm;
        }
        
        /// <summary>
        /// Gets or Sets EndTime
        /// </summary>
        [DataMember(Name="endTime", EmitDefaultValue=false)]
        public DimensionalTime EndTime { get; set; }

        /// <summary>
        /// Gets or Sets AdjointEndTime
        /// </summary>
        [DataMember(Name="adjointEndTime", EmitDefaultValue=false)]
        public DimensionalTime AdjointEndTime { get; set; }

        /// <summary>
        /// This represents the total number of iterations at which the simulation will terminate. No further iterations will be performed beyond this point. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/simulation-control/&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.
        /// </summary>
        /// <value>This represents the total number of iterations at which the simulation will terminate. No further iterations will be performed beyond this point. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/simulation-control/&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.</value>
        [DataMember(Name="numberOfIterations", EmitDefaultValue=false)]
        public int? NumberOfIterations { get; set; }

        /// <summary>
        /// Gets or Sets DeltaT
        /// </summary>
        [DataMember(Name="deltaT", EmitDefaultValue=false)]
        public DimensionalTime DeltaT { get; set; }

        /// <summary>
        /// Gets or Sets VariableDeltaT
        /// </summary>
        [DataMember(Name="variableDeltaT", EmitDefaultValue=false)]
        public DimensionalFunctionTime VariableDeltaT { get; set; }

        /// <summary>
        /// Gets or Sets AdjustableTimestep
        /// </summary>
        [DataMember(Name="adjustableTimestep", EmitDefaultValue=false)]
        public OneOfFluidSimulationControlAdjustableTimestep AdjustableTimestep { get; set; }

        /// <summary>
        /// Gets or Sets WriteControl
        /// </summary>
        [DataMember(Name="writeControl", EmitDefaultValue=false)]
        public OneOfFluidSimulationControlWriteControl WriteControl { get; set; }

        /// <summary>
        /// &lt;b&gt;Steady-state simulation:&lt;/b&gt; This represents the relative error residuals that once attained by the solver the simulation is considered to be converged and will stop. The recommended value is 0.001.&lt;br&gt; &lt;b&gt;Transient simulation:&lt;/b&gt; This represents the relative error residuals that once attained by the solver the simulation will move to the next time-step regardless of the &lt;i&gt;Number of iterations&lt;/i&gt;. The recommended value is 0.1.&lt;/br&gt; &lt;br&gt; &lt;b&gt;Please note: &lt;/b&gt;Relative residual is defined as the residual in the current iteration divided by the maximum value of residual calculated up to that point.&lt;/br&gt; &lt;br&gt; &lt;b&gt;Please note: &lt;/b&gt;Lower convergence criterion is demanded for &lt;b&gt;Steady-state simulations&lt;/b&gt; because the initial guess is typically farther from the correct solution.&lt;/br&gt;
        /// </summary>
        /// <value>&lt;b&gt;Steady-state simulation:&lt;/b&gt; This represents the relative error residuals that once attained by the solver the simulation is considered to be converged and will stop. The recommended value is 0.001.&lt;br&gt; &lt;b&gt;Transient simulation:&lt;/b&gt; This represents the relative error residuals that once attained by the solver the simulation will move to the next time-step regardless of the &lt;i&gt;Number of iterations&lt;/i&gt;. The recommended value is 0.1.&lt;/br&gt; &lt;br&gt; &lt;b&gt;Please note: &lt;/b&gt;Relative residual is defined as the residual in the current iteration divided by the maximum value of residual calculated up to that point.&lt;/br&gt; &lt;br&gt; &lt;b&gt;Please note: &lt;/b&gt;Lower convergence criterion is demanded for &lt;b&gt;Steady-state simulations&lt;/b&gt; because the initial guess is typically farther from the correct solution.&lt;/br&gt;</value>
        [DataMember(Name="relativeConvergenceCriteria", EmitDefaultValue=false)]
        public decimal? RelativeConvergenceCriteria { get; set; }

        /// <summary>
        /// &lt;p&gt;Selecting more processor cores will speed up the simulation process. Choosing a smaller computation instance will save core hours. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/simulation-control-fluid/#number-of-processors&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Selecting more processor cores will speed up the simulation process. Choosing a smaller computation instance will save core hours. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/simulation-setup/simulation-control-fluid/#number-of-processors&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.&lt;/p&gt;</value>
        [DataMember(Name="numProcessors", EmitDefaultValue=false)]
        public int? NumProcessors { get; set; }

        /// <summary>
        /// Gets or Sets MaxRunTime
        /// </summary>
        [DataMember(Name="maxRunTime", EmitDefaultValue=false)]
        public DimensionalTime MaxRunTime { get; set; }

        /// <summary>
        /// &lt;p&gt;It affects the stability of the simulation. The default value of 0.1 is a good compromise between accuracy and computational requirements. Lower values of this parameter might increase the stability of the simulation at the cost of higher computational time.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;It affects the stability of the simulation. The default value of 0.1 is a good compromise between accuracy and computational requirements. Lower values of this parameter might increase the stability of the simulation at the cost of higher computational time.&lt;/p&gt;</value>
        [DataMember(Name="velocityScaling", EmitDefaultValue=false)]
        public decimal? VelocityScaling { get; set; }

        /// <summary>
        /// This setting activates the solution of a potential flow field. The potential flow is used as initial condition for the actual simulation. This can accelerate convergence and improve stability during the first time steps. If you experience stability problems, this setting may bring some improvement.
        /// </summary>
        /// <value>This setting activates the solution of a potential flow field. The potential flow is used as initial condition for the actual simulation. This can accelerate convergence and improve stability during the first time steps. If you experience stability problems, this setting may bring some improvement.</value>
        [DataMember(Name="potentialFoamInitialization", EmitDefaultValue=false)]
        public bool? PotentialFoamInitialization { get; set; }

        /// <summary>
        /// Gets or Sets DecomposeAlgorithm
        /// </summary>
        [DataMember(Name="decomposeAlgorithm", EmitDefaultValue=false)]
        public OneOfFluidSimulationControlDecomposeAlgorithm DecomposeAlgorithm { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class FluidSimulationControl {\n");
            sb.Append("  EndTime: ").Append(EndTime).Append("\n");
            sb.Append("  AdjointEndTime: ").Append(AdjointEndTime).Append("\n");
            sb.Append("  NumberOfIterations: ").Append(NumberOfIterations).Append("\n");
            sb.Append("  DeltaT: ").Append(DeltaT).Append("\n");
            sb.Append("  VariableDeltaT: ").Append(VariableDeltaT).Append("\n");
            sb.Append("  AdjustableTimestep: ").Append(AdjustableTimestep).Append("\n");
            sb.Append("  WriteControl: ").Append(WriteControl).Append("\n");
            sb.Append("  RelativeConvergenceCriteria: ").Append(RelativeConvergenceCriteria).Append("\n");
            sb.Append("  NumProcessors: ").Append(NumProcessors).Append("\n");
            sb.Append("  MaxRunTime: ").Append(MaxRunTime).Append("\n");
            sb.Append("  VelocityScaling: ").Append(VelocityScaling).Append("\n");
            sb.Append("  PotentialFoamInitialization: ").Append(PotentialFoamInitialization).Append("\n");
            sb.Append("  DecomposeAlgorithm: ").Append(DecomposeAlgorithm).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as FluidSimulationControl);
        }

        /// <summary>
        /// Returns true if FluidSimulationControl instances are equal
        /// </summary>
        /// <param name="input">Instance of FluidSimulationControl to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(FluidSimulationControl input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.EndTime == input.EndTime ||
                    (this.EndTime != null &&
                    this.EndTime.Equals(input.EndTime))
                ) && 
                (
                    this.AdjointEndTime == input.AdjointEndTime ||
                    (this.AdjointEndTime != null &&
                    this.AdjointEndTime.Equals(input.AdjointEndTime))
                ) && 
                (
                    this.NumberOfIterations == input.NumberOfIterations ||
                    (this.NumberOfIterations != null &&
                    this.NumberOfIterations.Equals(input.NumberOfIterations))
                ) && 
                (
                    this.DeltaT == input.DeltaT ||
                    (this.DeltaT != null &&
                    this.DeltaT.Equals(input.DeltaT))
                ) && 
                (
                    this.VariableDeltaT == input.VariableDeltaT ||
                    (this.VariableDeltaT != null &&
                    this.VariableDeltaT.Equals(input.VariableDeltaT))
                ) && 
                (
                    this.AdjustableTimestep == input.AdjustableTimestep ||
                    (this.AdjustableTimestep != null &&
                    this.AdjustableTimestep.Equals(input.AdjustableTimestep))
                ) && 
                (
                    this.WriteControl == input.WriteControl ||
                    (this.WriteControl != null &&
                    this.WriteControl.Equals(input.WriteControl))
                ) && 
                (
                    this.RelativeConvergenceCriteria == input.RelativeConvergenceCriteria ||
                    (this.RelativeConvergenceCriteria != null &&
                    this.RelativeConvergenceCriteria.Equals(input.RelativeConvergenceCriteria))
                ) && 
                (
                    this.NumProcessors == input.NumProcessors ||
                    (this.NumProcessors != null &&
                    this.NumProcessors.Equals(input.NumProcessors))
                ) && 
                (
                    this.MaxRunTime == input.MaxRunTime ||
                    (this.MaxRunTime != null &&
                    this.MaxRunTime.Equals(input.MaxRunTime))
                ) && 
                (
                    this.VelocityScaling == input.VelocityScaling ||
                    (this.VelocityScaling != null &&
                    this.VelocityScaling.Equals(input.VelocityScaling))
                ) && 
                (
                    this.PotentialFoamInitialization == input.PotentialFoamInitialization ||
                    (this.PotentialFoamInitialization != null &&
                    this.PotentialFoamInitialization.Equals(input.PotentialFoamInitialization))
                ) && 
                (
                    this.DecomposeAlgorithm == input.DecomposeAlgorithm ||
                    (this.DecomposeAlgorithm != null &&
                    this.DecomposeAlgorithm.Equals(input.DecomposeAlgorithm))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.EndTime != null)
                    hashCode = hashCode * 59 + this.EndTime.GetHashCode();
                if (this.AdjointEndTime != null)
                    hashCode = hashCode * 59 + this.AdjointEndTime.GetHashCode();
                if (this.NumberOfIterations != null)
                    hashCode = hashCode * 59 + this.NumberOfIterations.GetHashCode();
                if (this.DeltaT != null)
                    hashCode = hashCode * 59 + this.DeltaT.GetHashCode();
                if (this.VariableDeltaT != null)
                    hashCode = hashCode * 59 + this.VariableDeltaT.GetHashCode();
                if (this.AdjustableTimestep != null)
                    hashCode = hashCode * 59 + this.AdjustableTimestep.GetHashCode();
                if (this.WriteControl != null)
                    hashCode = hashCode * 59 + this.WriteControl.GetHashCode();
                if (this.RelativeConvergenceCriteria != null)
                    hashCode = hashCode * 59 + this.RelativeConvergenceCriteria.GetHashCode();
                if (this.NumProcessors != null)
                    hashCode = hashCode * 59 + this.NumProcessors.GetHashCode();
                if (this.MaxRunTime != null)
                    hashCode = hashCode * 59 + this.MaxRunTime.GetHashCode();
                if (this.VelocityScaling != null)
                    hashCode = hashCode * 59 + this.VelocityScaling.GetHashCode();
                if (this.PotentialFoamInitialization != null)
                    hashCode = hashCode * 59 + this.PotentialFoamInitialization.GetHashCode();
                if (this.DecomposeAlgorithm != null)
                    hashCode = hashCode * 59 + this.DecomposeAlgorithm.GetHashCode();
                return hashCode;
            }
        }

    }

}
