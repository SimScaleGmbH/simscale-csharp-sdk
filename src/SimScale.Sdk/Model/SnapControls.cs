/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// SnapControls
    /// </summary>
    [DataContract]
    public partial class SnapControls : IEquatable<SnapControls>
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="SnapControls" /> class.
        /// </summary>
        /// <param name="meshToGeometryConformationIterations">&lt;p&gt;Define the max number of iterations to ensure that the mesh conforms to the geometry. Higher values lead to a better conforming mesh.&lt;/p&gt; (default to 5).</param>
        /// <param name="tolerance">&lt;p&gt;This parameter describes a distance (relative to the local maximum mesh edge length) within which the algorithm looks for a geometry point to snap the mesh to. Higher values lead to better snapping but are costlier.&lt;/p&gt; (default to 2M).</param>
        /// <param name="solverIterations">&lt;p&gt;This parameter defines the number of displacement relaxation iterations during the meshing process. Higher values lead to enhanced mesh quality but increase the computing time.&lt;/p&gt; (default to 150).</param>
        /// <param name="relaxIterations">&lt;p&gt;This parameter defines the max number of iterations to remove bad mesh points (see documentation).&lt;/p&gt; (default to 8).</param>
        /// <param name="maxMexConformationIterations">&lt;p&gt;This parameter defines the max number of iterations done to ensure that the mesh conforms to the geometry.&lt;/p&gt; (default to 10).</param>
        /// <param name="implicitFeatureSnap">&lt;p&gt;Activating this makes the snapping algorithm detecting geometrical features by sampling the surface. This might be time-consuming. The other option is to create a feature refinement which also enables feature snapping.&lt;/p&gt; (default to true).</param>
        /// <param name="explicitFeatureSnap">&lt;p&gt;Use the explicitly given feature refinements for feature snapping. An explicit feature refinement can be added under &#39;Mesh refinement&#39;. Specifying a feature refinement results in sharp mesh edges even with a refinement level of zero.&lt;/p&gt; (default to false).</param>
        /// <param name="detectFeaturesBetweenMultipleSurfaces">&lt;p&gt;Also detect features between multiple surfaces. This is relevant when you want to create a mesh with multiple regions - used for example in the conjugate heat transfer solver. Needs &#39;Use feature refinement for snapping&#39; turned on!&lt;/p&gt; (default to true).</param>
        public SnapControls(int? meshToGeometryConformationIterations = default(int?), decimal? tolerance = default(decimal?), int? solverIterations = default(int?), int? relaxIterations = default(int?), int? maxMexConformationIterations = default(int?), bool? implicitFeatureSnap = default(bool?), bool? explicitFeatureSnap = default(bool?), bool? detectFeaturesBetweenMultipleSurfaces = default(bool?))
        {
            this.MeshToGeometryConformationIterations = meshToGeometryConformationIterations;
            this.Tolerance = tolerance;
            this.SolverIterations = solverIterations;
            this.RelaxIterations = relaxIterations;
            this.MaxMexConformationIterations = maxMexConformationIterations;
            this.ImplicitFeatureSnap = implicitFeatureSnap;
            this.ExplicitFeatureSnap = explicitFeatureSnap;
            this.DetectFeaturesBetweenMultipleSurfaces = detectFeaturesBetweenMultipleSurfaces;
        }
        
        /// <summary>
        /// &lt;p&gt;Define the max number of iterations to ensure that the mesh conforms to the geometry. Higher values lead to a better conforming mesh.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Define the max number of iterations to ensure that the mesh conforms to the geometry. Higher values lead to a better conforming mesh.&lt;/p&gt;</value>
        [DataMember(Name="meshToGeometryConformationIterations", EmitDefaultValue=false)]
        public int? MeshToGeometryConformationIterations { get; set; }

        /// <summary>
        /// &lt;p&gt;This parameter describes a distance (relative to the local maximum mesh edge length) within which the algorithm looks for a geometry point to snap the mesh to. Higher values lead to better snapping but are costlier.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;This parameter describes a distance (relative to the local maximum mesh edge length) within which the algorithm looks for a geometry point to snap the mesh to. Higher values lead to better snapping but are costlier.&lt;/p&gt;</value>
        [DataMember(Name="tolerance", EmitDefaultValue=false)]
        public decimal? Tolerance { get; set; }

        /// <summary>
        /// &lt;p&gt;This parameter defines the number of displacement relaxation iterations during the meshing process. Higher values lead to enhanced mesh quality but increase the computing time.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;This parameter defines the number of displacement relaxation iterations during the meshing process. Higher values lead to enhanced mesh quality but increase the computing time.&lt;/p&gt;</value>
        [DataMember(Name="solverIterations", EmitDefaultValue=false)]
        public int? SolverIterations { get; set; }

        /// <summary>
        /// &lt;p&gt;This parameter defines the max number of iterations to remove bad mesh points (see documentation).&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;This parameter defines the max number of iterations to remove bad mesh points (see documentation).&lt;/p&gt;</value>
        [DataMember(Name="relaxIterations", EmitDefaultValue=false)]
        public int? RelaxIterations { get; set; }

        /// <summary>
        /// &lt;p&gt;This parameter defines the max number of iterations done to ensure that the mesh conforms to the geometry.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;This parameter defines the max number of iterations done to ensure that the mesh conforms to the geometry.&lt;/p&gt;</value>
        [DataMember(Name="maxMexConformationIterations", EmitDefaultValue=false)]
        public int? MaxMexConformationIterations { get; set; }

        /// <summary>
        /// &lt;p&gt;Activating this makes the snapping algorithm detecting geometrical features by sampling the surface. This might be time-consuming. The other option is to create a feature refinement which also enables feature snapping.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Activating this makes the snapping algorithm detecting geometrical features by sampling the surface. This might be time-consuming. The other option is to create a feature refinement which also enables feature snapping.&lt;/p&gt;</value>
        [DataMember(Name="implicitFeatureSnap", EmitDefaultValue=false)]
        public bool? ImplicitFeatureSnap { get; set; }

        /// <summary>
        /// &lt;p&gt;Use the explicitly given feature refinements for feature snapping. An explicit feature refinement can be added under &#39;Mesh refinement&#39;. Specifying a feature refinement results in sharp mesh edges even with a refinement level of zero.&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Use the explicitly given feature refinements for feature snapping. An explicit feature refinement can be added under &#39;Mesh refinement&#39;. Specifying a feature refinement results in sharp mesh edges even with a refinement level of zero.&lt;/p&gt;</value>
        [DataMember(Name="explicitFeatureSnap", EmitDefaultValue=false)]
        public bool? ExplicitFeatureSnap { get; set; }

        /// <summary>
        /// &lt;p&gt;Also detect features between multiple surfaces. This is relevant when you want to create a mesh with multiple regions - used for example in the conjugate heat transfer solver. Needs &#39;Use feature refinement for snapping&#39; turned on!&lt;/p&gt;
        /// </summary>
        /// <value>&lt;p&gt;Also detect features between multiple surfaces. This is relevant when you want to create a mesh with multiple regions - used for example in the conjugate heat transfer solver. Needs &#39;Use feature refinement for snapping&#39; turned on!&lt;/p&gt;</value>
        [DataMember(Name="detectFeaturesBetweenMultipleSurfaces", EmitDefaultValue=false)]
        public bool? DetectFeaturesBetweenMultipleSurfaces { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class SnapControls {\n");
            sb.Append("  MeshToGeometryConformationIterations: ").Append(MeshToGeometryConformationIterations).Append("\n");
            sb.Append("  Tolerance: ").Append(Tolerance).Append("\n");
            sb.Append("  SolverIterations: ").Append(SolverIterations).Append("\n");
            sb.Append("  RelaxIterations: ").Append(RelaxIterations).Append("\n");
            sb.Append("  MaxMexConformationIterations: ").Append(MaxMexConformationIterations).Append("\n");
            sb.Append("  ImplicitFeatureSnap: ").Append(ImplicitFeatureSnap).Append("\n");
            sb.Append("  ExplicitFeatureSnap: ").Append(ExplicitFeatureSnap).Append("\n");
            sb.Append("  DetectFeaturesBetweenMultipleSurfaces: ").Append(DetectFeaturesBetweenMultipleSurfaces).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as SnapControls);
        }

        /// <summary>
        /// Returns true if SnapControls instances are equal
        /// </summary>
        /// <param name="input">Instance of SnapControls to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(SnapControls input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.MeshToGeometryConformationIterations == input.MeshToGeometryConformationIterations ||
                    (this.MeshToGeometryConformationIterations != null &&
                    this.MeshToGeometryConformationIterations.Equals(input.MeshToGeometryConformationIterations))
                ) && 
                (
                    this.Tolerance == input.Tolerance ||
                    (this.Tolerance != null &&
                    this.Tolerance.Equals(input.Tolerance))
                ) && 
                (
                    this.SolverIterations == input.SolverIterations ||
                    (this.SolverIterations != null &&
                    this.SolverIterations.Equals(input.SolverIterations))
                ) && 
                (
                    this.RelaxIterations == input.RelaxIterations ||
                    (this.RelaxIterations != null &&
                    this.RelaxIterations.Equals(input.RelaxIterations))
                ) && 
                (
                    this.MaxMexConformationIterations == input.MaxMexConformationIterations ||
                    (this.MaxMexConformationIterations != null &&
                    this.MaxMexConformationIterations.Equals(input.MaxMexConformationIterations))
                ) && 
                (
                    this.ImplicitFeatureSnap == input.ImplicitFeatureSnap ||
                    (this.ImplicitFeatureSnap != null &&
                    this.ImplicitFeatureSnap.Equals(input.ImplicitFeatureSnap))
                ) && 
                (
                    this.ExplicitFeatureSnap == input.ExplicitFeatureSnap ||
                    (this.ExplicitFeatureSnap != null &&
                    this.ExplicitFeatureSnap.Equals(input.ExplicitFeatureSnap))
                ) && 
                (
                    this.DetectFeaturesBetweenMultipleSurfaces == input.DetectFeaturesBetweenMultipleSurfaces ||
                    (this.DetectFeaturesBetweenMultipleSurfaces != null &&
                    this.DetectFeaturesBetweenMultipleSurfaces.Equals(input.DetectFeaturesBetweenMultipleSurfaces))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.MeshToGeometryConformationIterations != null)
                    hashCode = hashCode * 59 + this.MeshToGeometryConformationIterations.GetHashCode();
                if (this.Tolerance != null)
                    hashCode = hashCode * 59 + this.Tolerance.GetHashCode();
                if (this.SolverIterations != null)
                    hashCode = hashCode * 59 + this.SolverIterations.GetHashCode();
                if (this.RelaxIterations != null)
                    hashCode = hashCode * 59 + this.RelaxIterations.GetHashCode();
                if (this.MaxMexConformationIterations != null)
                    hashCode = hashCode * 59 + this.MaxMexConformationIterations.GetHashCode();
                if (this.ImplicitFeatureSnap != null)
                    hashCode = hashCode * 59 + this.ImplicitFeatureSnap.GetHashCode();
                if (this.ExplicitFeatureSnap != null)
                    hashCode = hashCode * 59 + this.ExplicitFeatureSnap.GetHashCode();
                if (this.DetectFeaturesBetweenMultipleSurfaces != null)
                    hashCode = hashCode * 59 + this.DetectFeaturesBetweenMultipleSurfaces.GetHashCode();
                return hashCode;
            }
        }

    }

}
