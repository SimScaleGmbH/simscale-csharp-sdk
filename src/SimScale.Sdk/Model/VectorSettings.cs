/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// VectorSettings
    /// </summary>
    [DataContract]
    public partial class VectorSettings : IEquatable<VectorSettings>
    {
        /// <summary>
        /// Defines Coloring
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum ColoringEnum
        {
            /// <summary>
            /// Enum BYVECTORFIELD for value: BY_VECTOR_FIELD
            /// </summary>
            [EnumMember(Value = "BY_VECTOR_FIELD")]
            BYVECTORFIELD = 1,

            /// <summary>
            /// Enum SOLIDCOLOR for value: SOLID_COLOR
            /// </summary>
            [EnumMember(Value = "SOLID_COLOR")]
            SOLIDCOLOR = 2

        }

        /// <summary>
        /// Gets or Sets Coloring
        /// </summary>
        [DataMember(Name="coloring", EmitDefaultValue=false)]
        public ColoringEnum Coloring { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="VectorSettings" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected VectorSettings() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="VectorSettings" /> class.
        /// </summary>
        /// <param name="vectorField">vectorField (required).</param>
        /// <param name="scaleFactor">scaleFactor (required) (default to 0.2F).</param>
        /// <param name="solidColor">solidColor.</param>
        /// <param name="coloring">coloring (required) (default to ColoringEnum.BYVECTORFIELD).</param>
        /// <param name="minimumClampingRange">The minimum length of (non-zero) vectors will be drawn as. Must not be larger than maximumClampingRange. Default value is the minimum length of the specified vector field..</param>
        /// <param name="maximumClampingRange">The maximum length of (non-zero) vectors will be drawn as. Must not be smaller than minimumClampingRange. Default value is the maximum length of the specified vector field..</param>
        /// <param name="minimumFilteringRange">The required minimum length of the vectors in order to be drawn. Must not be larger than maximumFilteringRange. Default value is the minimum length of the specified vector field..</param>
        /// <param name="maximumFilteringRange">The required maximum length of the vectors in order to be drawn. Must not be smaller than minimumFilteringRange. Default value is the maximum length of the specified vector field..</param>
        public VectorSettings(VectorField vectorField = default(VectorField), float? scaleFactor = 0.2F, Color solidColor = default(Color), ColoringEnum coloring = ColoringEnum.BYVECTORFIELD, float? minimumClampingRange = default(float?), float? maximumClampingRange = default(float?), float? minimumFilteringRange = default(float?), float? maximumFilteringRange = default(float?))
        {
            // to ensure "vectorField" is required (not null)
            this.VectorField = vectorField ?? throw new ArgumentNullException("vectorField is a required property for VectorSettings and cannot be null");
            // to ensure "scaleFactor" is required (not null)
            this.ScaleFactor = scaleFactor ?? throw new ArgumentNullException("scaleFactor is a required property for VectorSettings and cannot be null");
            this.Coloring = coloring;
            this.SolidColor = solidColor;
            this.MinimumClampingRange = minimumClampingRange;
            this.MaximumClampingRange = maximumClampingRange;
            this.MinimumFilteringRange = minimumFilteringRange;
            this.MaximumFilteringRange = maximumFilteringRange;
        }
        
        /// <summary>
        /// Gets or Sets VectorField
        /// </summary>
        [DataMember(Name="vectorField", EmitDefaultValue=false)]
        public VectorField VectorField { get; set; }

        /// <summary>
        /// Gets or Sets ScaleFactor
        /// </summary>
        [DataMember(Name="scaleFactor", EmitDefaultValue=false)]
        public float? ScaleFactor { get; set; }

        /// <summary>
        /// Gets or Sets SolidColor
        /// </summary>
        [DataMember(Name="solidColor", EmitDefaultValue=false)]
        public Color SolidColor { get; set; }

        /// <summary>
        /// The minimum length of (non-zero) vectors will be drawn as. Must not be larger than maximumClampingRange. Default value is the minimum length of the specified vector field.
        /// </summary>
        /// <value>The minimum length of (non-zero) vectors will be drawn as. Must not be larger than maximumClampingRange. Default value is the minimum length of the specified vector field.</value>
        [DataMember(Name="minimumClampingRange", EmitDefaultValue=false)]
        public float? MinimumClampingRange { get; set; }

        /// <summary>
        /// The maximum length of (non-zero) vectors will be drawn as. Must not be smaller than minimumClampingRange. Default value is the maximum length of the specified vector field.
        /// </summary>
        /// <value>The maximum length of (non-zero) vectors will be drawn as. Must not be smaller than minimumClampingRange. Default value is the maximum length of the specified vector field.</value>
        [DataMember(Name="maximumClampingRange", EmitDefaultValue=false)]
        public float? MaximumClampingRange { get; set; }

        /// <summary>
        /// The required minimum length of the vectors in order to be drawn. Must not be larger than maximumFilteringRange. Default value is the minimum length of the specified vector field.
        /// </summary>
        /// <value>The required minimum length of the vectors in order to be drawn. Must not be larger than maximumFilteringRange. Default value is the minimum length of the specified vector field.</value>
        [DataMember(Name="minimumFilteringRange", EmitDefaultValue=false)]
        public float? MinimumFilteringRange { get; set; }

        /// <summary>
        /// The required maximum length of the vectors in order to be drawn. Must not be smaller than minimumFilteringRange. Default value is the maximum length of the specified vector field.
        /// </summary>
        /// <value>The required maximum length of the vectors in order to be drawn. Must not be smaller than minimumFilteringRange. Default value is the maximum length of the specified vector field.</value>
        [DataMember(Name="maximumFilteringRange", EmitDefaultValue=false)]
        public float? MaximumFilteringRange { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class VectorSettings {\n");
            sb.Append("  VectorField: ").Append(VectorField).Append("\n");
            sb.Append("  ScaleFactor: ").Append(ScaleFactor).Append("\n");
            sb.Append("  SolidColor: ").Append(SolidColor).Append("\n");
            sb.Append("  Coloring: ").Append(Coloring).Append("\n");
            sb.Append("  MinimumClampingRange: ").Append(MinimumClampingRange).Append("\n");
            sb.Append("  MaximumClampingRange: ").Append(MaximumClampingRange).Append("\n");
            sb.Append("  MinimumFilteringRange: ").Append(MinimumFilteringRange).Append("\n");
            sb.Append("  MaximumFilteringRange: ").Append(MaximumFilteringRange).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as VectorSettings);
        }

        /// <summary>
        /// Returns true if VectorSettings instances are equal
        /// </summary>
        /// <param name="input">Instance of VectorSettings to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(VectorSettings input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.VectorField == input.VectorField ||
                    (this.VectorField != null &&
                    this.VectorField.Equals(input.VectorField))
                ) && 
                (
                    this.ScaleFactor == input.ScaleFactor ||
                    (this.ScaleFactor != null &&
                    this.ScaleFactor.Equals(input.ScaleFactor))
                ) && 
                (
                    this.SolidColor == input.SolidColor ||
                    (this.SolidColor != null &&
                    this.SolidColor.Equals(input.SolidColor))
                ) && 
                (
                    this.Coloring == input.Coloring ||
                    this.Coloring.Equals(input.Coloring)
                ) && 
                (
                    this.MinimumClampingRange == input.MinimumClampingRange ||
                    (this.MinimumClampingRange != null &&
                    this.MinimumClampingRange.Equals(input.MinimumClampingRange))
                ) && 
                (
                    this.MaximumClampingRange == input.MaximumClampingRange ||
                    (this.MaximumClampingRange != null &&
                    this.MaximumClampingRange.Equals(input.MaximumClampingRange))
                ) && 
                (
                    this.MinimumFilteringRange == input.MinimumFilteringRange ||
                    (this.MinimumFilteringRange != null &&
                    this.MinimumFilteringRange.Equals(input.MinimumFilteringRange))
                ) && 
                (
                    this.MaximumFilteringRange == input.MaximumFilteringRange ||
                    (this.MaximumFilteringRange != null &&
                    this.MaximumFilteringRange.Equals(input.MaximumFilteringRange))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.VectorField != null)
                    hashCode = hashCode * 59 + this.VectorField.GetHashCode();
                if (this.ScaleFactor != null)
                    hashCode = hashCode * 59 + this.ScaleFactor.GetHashCode();
                if (this.SolidColor != null)
                    hashCode = hashCode * 59 + this.SolidColor.GetHashCode();
                hashCode = hashCode * 59 + this.Coloring.GetHashCode();
                if (this.MinimumClampingRange != null)
                    hashCode = hashCode * 59 + this.MinimumClampingRange.GetHashCode();
                if (this.MaximumClampingRange != null)
                    hashCode = hashCode * 59 + this.MaximumClampingRange.GetHashCode();
                if (this.MinimumFilteringRange != null)
                    hashCode = hashCode * 59 + this.MinimumFilteringRange.GetHashCode();
                if (this.MaximumFilteringRange != null)
                    hashCode = hashCode * 59 + this.MaximumFilteringRange.GetHashCode();
                return hashCode;
            }
        }

    }

}
