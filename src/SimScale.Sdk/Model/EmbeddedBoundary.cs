/* 
 * SimScale API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using OpenAPIDateConverter = SimScale.Sdk.Client.OpenAPIDateConverter;

namespace SimScale.Sdk.Model
{
    /// <summary>
    /// EmbeddedBoundary
    /// </summary>
    [DataContract]
    public partial class EmbeddedBoundary : Analysis, IEquatable<EmbeddedBoundary>
    {
        /// <summary>
        /// Defines TurbulenceModel
        /// </summary>
        [JsonConverter(typeof(StringEnumConverter))]
        public enum TurbulenceModelEnum
        {
            /// <summary>
            /// Enum NONE for value: NONE
            /// </summary>
            [EnumMember(Value = "NONE")]
            NONE = 1,

            /// <summary>
            /// Enum KOMEGASST for value: KOMEGASST
            /// </summary>
            [EnumMember(Value = "KOMEGASST")]
            KOMEGASST = 2

        }

        /// <summary>
        /// Gets or Sets TurbulenceModel
        /// </summary>
        [DataMember(Name="turbulenceModel", EmitDefaultValue=false)]
        public TurbulenceModelEnum? TurbulenceModel { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="EmbeddedBoundary" /> class.
        /// </summary>
        [JsonConstructorAttribute]
        protected EmbeddedBoundary() { }
        /// <summary>
        /// Initializes a new instance of the <see cref="EmbeddedBoundary" /> class.
        /// </summary>
        /// <param name="type">Schema name: EmbeddedBoundary (required) (default to &quot;EMBEDDED_BOUNDARY&quot;).</param>
        /// <param name="allowExternalFlow">This toggle allows you to create an additional external fluid domain via a Cartesian box. Enable this toggle if you want to simulate for example natural convection around your system and the external flow domain is not represented in your CAD model as a solid body. (default to false).</param>
        /// <param name="model">model.</param>
        /// <param name="materials">materials.</param>
        /// <param name="initialConditions">initialConditions.</param>
        /// <param name="externalFlowBoundaryCondition">externalFlowBoundaryCondition.</param>
        /// <param name="boundaryConditions">boundaryConditions.</param>
        /// <param name="advancedConcepts">advancedConcepts.</param>
        /// <param name="numerics">numerics.</param>
        /// <param name="simulationControl">simulationControl.</param>
        /// <param name="resultControl">resultControl.</param>
        /// <param name="embeddedBoundaryMeshing">embeddedBoundaryMeshing.</param>
        /// <param name="isCompressible">&lt;ul&gt;&lt;li&gt;Toggle off &lt;em&gt;Compressible&lt;/em&gt; for small temperature variations within the domain, for example, in natural convection simulations (Boussinesq approximation). Use Gauge pressure (0 Pa). &lt;/li&gt;&lt;li&gt;Toggle on &lt;em&gt;Compressible&lt;/em&gt; to calculate resulting density variations within the domain based on pressure and temperature. Use Absolute pressure (for example, 101325 Pa at sea level)&lt;/li&gt;&lt;/ul&gt; (default to false).</param>
        /// <param name="enableRadiation">Heat transfer through radiation takes place in the form of electromagnetic waves and it can be calculated in the simulation. This phenomenon becomes more important when the temperature differences in the simulation domain are large. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/analysis-types/convective-heat-transfer-analysis/radiation/&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;. (default to false).</param>
        /// <param name="enableJouleHeating">Enabling &lt;b&gt;Joule heating&lt;/b&gt; gives you the possibility to solve a coupled electric conduction and conjugate heat transfer problem in a single simulation. (default to false).</param>
        /// <param name="turbulenceModel">turbulenceModel (default to TurbulenceModelEnum.KOMEGASST).</param>
        /// <param name="timeDependency">timeDependency.</param>
        public EmbeddedBoundary(string type = "EMBEDDED_BOUNDARY", bool? allowExternalFlow = default(bool?), FluidModel model = default(FluidModel), CoupledConjugateHeatTransferMaterials materials = default(CoupledConjugateHeatTransferMaterials), FluidInitialConditions initialConditions = default(FluidInitialConditions), OneOfEmbeddedBoundaryExternalFlowBoundaryCondition externalFlowBoundaryCondition = default(OneOfEmbeddedBoundaryExternalFlowBoundaryCondition), List<OneOfEmbeddedBoundaryBoundaryConditions> boundaryConditions = default(List<OneOfEmbeddedBoundaryBoundaryConditions>), AdvancedConcepts advancedConcepts = default(AdvancedConcepts), FluidNumerics numerics = default(FluidNumerics), FluidSimulationControl simulationControl = default(FluidSimulationControl), FluidResultControls resultControl = default(FluidResultControls), EmbeddedBoundaryMeshing embeddedBoundaryMeshing = default(EmbeddedBoundaryMeshing), bool? isCompressible = default(bool?), bool? enableRadiation = default(bool?), bool? enableJouleHeating = default(bool?), TurbulenceModelEnum? turbulenceModel = default(TurbulenceModelEnum?), OneOfEmbeddedBoundaryTimeDependency timeDependency = default(OneOfEmbeddedBoundaryTimeDependency))
        {
            // to ensure "type" is required (not null)
            this.Type = type ?? throw new ArgumentNullException("type is a required property for EmbeddedBoundary and cannot be null");
            this.AllowExternalFlow = allowExternalFlow;
            this.Model = model;
            this.Materials = materials;
            this.InitialConditions = initialConditions;
            this.ExternalFlowBoundaryCondition = externalFlowBoundaryCondition;
            this.BoundaryConditions = boundaryConditions;
            this.AdvancedConcepts = advancedConcepts;
            this.Numerics = numerics;
            this.SimulationControl = simulationControl;
            this.ResultControl = resultControl;
            this.EmbeddedBoundaryMeshing = embeddedBoundaryMeshing;
            this.IsCompressible = isCompressible;
            this.EnableRadiation = enableRadiation;
            this.EnableJouleHeating = enableJouleHeating;
            this.TurbulenceModel = turbulenceModel;
            this.TimeDependency = timeDependency;
        }
        
        /// <summary>
        /// Schema name: EmbeddedBoundary
        /// </summary>
        /// <value>Schema name: EmbeddedBoundary</value>
        [DataMember(Name="type", EmitDefaultValue=false)]
        public string Type { get; set; }

        /// <summary>
        /// This toggle allows you to create an additional external fluid domain via a Cartesian box. Enable this toggle if you want to simulate for example natural convection around your system and the external flow domain is not represented in your CAD model as a solid body.
        /// </summary>
        /// <value>This toggle allows you to create an additional external fluid domain via a Cartesian box. Enable this toggle if you want to simulate for example natural convection around your system and the external flow domain is not represented in your CAD model as a solid body.</value>
        [DataMember(Name="allowExternalFlow", EmitDefaultValue=false)]
        public bool? AllowExternalFlow { get; set; }

        /// <summary>
        /// Gets or Sets Model
        /// </summary>
        [DataMember(Name="model", EmitDefaultValue=false)]
        public FluidModel Model { get; set; }

        /// <summary>
        /// Gets or Sets Materials
        /// </summary>
        [DataMember(Name="materials", EmitDefaultValue=false)]
        public CoupledConjugateHeatTransferMaterials Materials { get; set; }

        /// <summary>
        /// Gets or Sets InitialConditions
        /// </summary>
        [DataMember(Name="initialConditions", EmitDefaultValue=false)]
        public FluidInitialConditions InitialConditions { get; set; }

        /// <summary>
        /// Gets or Sets ExternalFlowBoundaryCondition
        /// </summary>
        [DataMember(Name="externalFlowBoundaryCondition", EmitDefaultValue=false)]
        public OneOfEmbeddedBoundaryExternalFlowBoundaryCondition ExternalFlowBoundaryCondition { get; set; }

        /// <summary>
        /// Gets or Sets BoundaryConditions
        /// </summary>
        [DataMember(Name="boundaryConditions", EmitDefaultValue=false)]
        public List<OneOfEmbeddedBoundaryBoundaryConditions> BoundaryConditions { get; set; }

        /// <summary>
        /// Gets or Sets AdvancedConcepts
        /// </summary>
        [DataMember(Name="advancedConcepts", EmitDefaultValue=false)]
        public AdvancedConcepts AdvancedConcepts { get; set; }

        /// <summary>
        /// Gets or Sets Numerics
        /// </summary>
        [DataMember(Name="numerics", EmitDefaultValue=false)]
        public FluidNumerics Numerics { get; set; }

        /// <summary>
        /// Gets or Sets SimulationControl
        /// </summary>
        [DataMember(Name="simulationControl", EmitDefaultValue=false)]
        public FluidSimulationControl SimulationControl { get; set; }

        /// <summary>
        /// Gets or Sets ResultControl
        /// </summary>
        [DataMember(Name="resultControl", EmitDefaultValue=false)]
        public FluidResultControls ResultControl { get; set; }

        /// <summary>
        /// Gets or Sets EmbeddedBoundaryMeshing
        /// </summary>
        [DataMember(Name="embeddedBoundaryMeshing", EmitDefaultValue=false)]
        public EmbeddedBoundaryMeshing EmbeddedBoundaryMeshing { get; set; }

        /// <summary>
        /// &lt;ul&gt;&lt;li&gt;Toggle off &lt;em&gt;Compressible&lt;/em&gt; for small temperature variations within the domain, for example, in natural convection simulations (Boussinesq approximation). Use Gauge pressure (0 Pa). &lt;/li&gt;&lt;li&gt;Toggle on &lt;em&gt;Compressible&lt;/em&gt; to calculate resulting density variations within the domain based on pressure and temperature. Use Absolute pressure (for example, 101325 Pa at sea level)&lt;/li&gt;&lt;/ul&gt;
        /// </summary>
        /// <value>&lt;ul&gt;&lt;li&gt;Toggle off &lt;em&gt;Compressible&lt;/em&gt; for small temperature variations within the domain, for example, in natural convection simulations (Boussinesq approximation). Use Gauge pressure (0 Pa). &lt;/li&gt;&lt;li&gt;Toggle on &lt;em&gt;Compressible&lt;/em&gt; to calculate resulting density variations within the domain based on pressure and temperature. Use Absolute pressure (for example, 101325 Pa at sea level)&lt;/li&gt;&lt;/ul&gt;</value>
        [DataMember(Name="isCompressible", EmitDefaultValue=false)]
        public bool? IsCompressible { get; set; }

        /// <summary>
        /// Heat transfer through radiation takes place in the form of electromagnetic waves and it can be calculated in the simulation. This phenomenon becomes more important when the temperature differences in the simulation domain are large. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/analysis-types/convective-heat-transfer-analysis/radiation/&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.
        /// </summary>
        /// <value>Heat transfer through radiation takes place in the form of electromagnetic waves and it can be calculated in the simulation. This phenomenon becomes more important when the temperature differences in the simulation domain are large. &lt;a href&#x3D;&#39;https://www.simscale.com/docs/analysis-types/convective-heat-transfer-analysis/radiation/&#39; target&#x3D;&#39;_blank&#39;&gt;Learn more&lt;/a&gt;.</value>
        [DataMember(Name="enableRadiation", EmitDefaultValue=false)]
        public bool? EnableRadiation { get; set; }

        /// <summary>
        /// Enabling &lt;b&gt;Joule heating&lt;/b&gt; gives you the possibility to solve a coupled electric conduction and conjugate heat transfer problem in a single simulation.
        /// </summary>
        /// <value>Enabling &lt;b&gt;Joule heating&lt;/b&gt; gives you the possibility to solve a coupled electric conduction and conjugate heat transfer problem in a single simulation.</value>
        [DataMember(Name="enableJouleHeating", EmitDefaultValue=false)]
        public bool? EnableJouleHeating { get; set; }

        /// <summary>
        /// Gets or Sets TimeDependency
        /// </summary>
        [DataMember(Name="timeDependency", EmitDefaultValue=false)]
        public OneOfEmbeddedBoundaryTimeDependency TimeDependency { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class EmbeddedBoundary {\n");
            sb.Append("  Type: ").Append(Type).Append("\n");
            sb.Append("  AllowExternalFlow: ").Append(AllowExternalFlow).Append("\n");
            sb.Append("  Model: ").Append(Model).Append("\n");
            sb.Append("  Materials: ").Append(Materials).Append("\n");
            sb.Append("  InitialConditions: ").Append(InitialConditions).Append("\n");
            sb.Append("  ExternalFlowBoundaryCondition: ").Append(ExternalFlowBoundaryCondition).Append("\n");
            sb.Append("  BoundaryConditions: ").Append(BoundaryConditions).Append("\n");
            sb.Append("  AdvancedConcepts: ").Append(AdvancedConcepts).Append("\n");
            sb.Append("  Numerics: ").Append(Numerics).Append("\n");
            sb.Append("  SimulationControl: ").Append(SimulationControl).Append("\n");
            sb.Append("  ResultControl: ").Append(ResultControl).Append("\n");
            sb.Append("  EmbeddedBoundaryMeshing: ").Append(EmbeddedBoundaryMeshing).Append("\n");
            sb.Append("  IsCompressible: ").Append(IsCompressible).Append("\n");
            sb.Append("  EnableRadiation: ").Append(EnableRadiation).Append("\n");
            sb.Append("  EnableJouleHeating: ").Append(EnableJouleHeating).Append("\n");
            sb.Append("  TurbulenceModel: ").Append(TurbulenceModel).Append("\n");
            sb.Append("  TimeDependency: ").Append(TimeDependency).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as EmbeddedBoundary);
        }

        /// <summary>
        /// Returns true if EmbeddedBoundary instances are equal
        /// </summary>
        /// <param name="input">Instance of EmbeddedBoundary to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(EmbeddedBoundary input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Type == input.Type ||
                    (this.Type != null &&
                    this.Type.Equals(input.Type))
                ) && 
                (
                    this.AllowExternalFlow == input.AllowExternalFlow ||
                    (this.AllowExternalFlow != null &&
                    this.AllowExternalFlow.Equals(input.AllowExternalFlow))
                ) && 
                (
                    this.Model == input.Model ||
                    (this.Model != null &&
                    this.Model.Equals(input.Model))
                ) && 
                (
                    this.Materials == input.Materials ||
                    (this.Materials != null &&
                    this.Materials.Equals(input.Materials))
                ) && 
                (
                    this.InitialConditions == input.InitialConditions ||
                    (this.InitialConditions != null &&
                    this.InitialConditions.Equals(input.InitialConditions))
                ) && 
                (
                    this.ExternalFlowBoundaryCondition == input.ExternalFlowBoundaryCondition ||
                    (this.ExternalFlowBoundaryCondition != null &&
                    this.ExternalFlowBoundaryCondition.Equals(input.ExternalFlowBoundaryCondition))
                ) && 
                (
                    this.BoundaryConditions == input.BoundaryConditions ||
                    this.BoundaryConditions != null &&
                    input.BoundaryConditions != null &&
                    this.BoundaryConditions.SequenceEqual(input.BoundaryConditions)
                ) && 
                (
                    this.AdvancedConcepts == input.AdvancedConcepts ||
                    (this.AdvancedConcepts != null &&
                    this.AdvancedConcepts.Equals(input.AdvancedConcepts))
                ) && 
                (
                    this.Numerics == input.Numerics ||
                    (this.Numerics != null &&
                    this.Numerics.Equals(input.Numerics))
                ) && 
                (
                    this.SimulationControl == input.SimulationControl ||
                    (this.SimulationControl != null &&
                    this.SimulationControl.Equals(input.SimulationControl))
                ) && 
                (
                    this.ResultControl == input.ResultControl ||
                    (this.ResultControl != null &&
                    this.ResultControl.Equals(input.ResultControl))
                ) && 
                (
                    this.EmbeddedBoundaryMeshing == input.EmbeddedBoundaryMeshing ||
                    (this.EmbeddedBoundaryMeshing != null &&
                    this.EmbeddedBoundaryMeshing.Equals(input.EmbeddedBoundaryMeshing))
                ) && 
                (
                    this.IsCompressible == input.IsCompressible ||
                    (this.IsCompressible != null &&
                    this.IsCompressible.Equals(input.IsCompressible))
                ) && 
                (
                    this.EnableRadiation == input.EnableRadiation ||
                    (this.EnableRadiation != null &&
                    this.EnableRadiation.Equals(input.EnableRadiation))
                ) && 
                (
                    this.EnableJouleHeating == input.EnableJouleHeating ||
                    (this.EnableJouleHeating != null &&
                    this.EnableJouleHeating.Equals(input.EnableJouleHeating))
                ) && 
                (
                    this.TurbulenceModel == input.TurbulenceModel ||
                    this.TurbulenceModel.Equals(input.TurbulenceModel)
                ) && 
                (
                    this.TimeDependency == input.TimeDependency ||
                    (this.TimeDependency != null &&
                    this.TimeDependency.Equals(input.TimeDependency))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Type != null)
                    hashCode = hashCode * 59 + this.Type.GetHashCode();
                if (this.AllowExternalFlow != null)
                    hashCode = hashCode * 59 + this.AllowExternalFlow.GetHashCode();
                if (this.Model != null)
                    hashCode = hashCode * 59 + this.Model.GetHashCode();
                if (this.Materials != null)
                    hashCode = hashCode * 59 + this.Materials.GetHashCode();
                if (this.InitialConditions != null)
                    hashCode = hashCode * 59 + this.InitialConditions.GetHashCode();
                if (this.ExternalFlowBoundaryCondition != null)
                    hashCode = hashCode * 59 + this.ExternalFlowBoundaryCondition.GetHashCode();
                if (this.BoundaryConditions != null)
                    hashCode = hashCode * 59 + this.BoundaryConditions.GetHashCode();
                if (this.AdvancedConcepts != null)
                    hashCode = hashCode * 59 + this.AdvancedConcepts.GetHashCode();
                if (this.Numerics != null)
                    hashCode = hashCode * 59 + this.Numerics.GetHashCode();
                if (this.SimulationControl != null)
                    hashCode = hashCode * 59 + this.SimulationControl.GetHashCode();
                if (this.ResultControl != null)
                    hashCode = hashCode * 59 + this.ResultControl.GetHashCode();
                if (this.EmbeddedBoundaryMeshing != null)
                    hashCode = hashCode * 59 + this.EmbeddedBoundaryMeshing.GetHashCode();
                if (this.IsCompressible != null)
                    hashCode = hashCode * 59 + this.IsCompressible.GetHashCode();
                if (this.EnableRadiation != null)
                    hashCode = hashCode * 59 + this.EnableRadiation.GetHashCode();
                if (this.EnableJouleHeating != null)
                    hashCode = hashCode * 59 + this.EnableJouleHeating.GetHashCode();
                hashCode = hashCode * 59 + this.TurbulenceModel.GetHashCode();
                if (this.TimeDependency != null)
                    hashCode = hashCode * 59 + this.TimeDependency.GetHashCode();
                return hashCode;
            }
        }

    }

}
